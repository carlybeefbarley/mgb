const ToolCircle = {
  label: 'Circle',
  name: 'circleTool',
  tooltip:
    'Click and drag to draw a circle/ellipse. Use SHIFT+drag for filled shapes. Use CTRL+drag to constrain to circle',
  icon: 'circle icon', // Semantic-UI icon CSS class
  editCursor: 'crosshair',
  supportsDrag: true,
  shortcut: 'o',
  changesImage: true, // This does cause changes to the image, so image is dirty if this tool used
  level: 8,

  handleMouseDown(drawEnv) {
    // drawEnv is in the format generated by EditGraphic.collateDrawingToolEnv()

    ToolCircle._storedPreviewImageData = drawEnv.previewCtx.getImageData(0, 0, drawEnv.width, drawEnv.height)
    ToolCircle._startx = drawEnv.x
    ToolCircle._starty = drawEnv.y
  },

  handleMouseMove(drawEnv) {
    let w = drawEnv.x - ToolCircle._startx
    let h = drawEnv.y - ToolCircle._starty
    const fillFlag = drawEnv.event.shiftKey === true
    const circleFlag = drawEnv.event.ctrlKey === true
    const y = circleFlag ? ToolCircle._starty + Math.sign(h) * Math.abs(w) : drawEnv.y

    // reset the preview canvas to how it was at MouseDown
    drawEnv.previewCtx.putImageData(ToolCircle._storedPreviewImageData, 0, 0)

    // Draw a circle here
    drawEllipseRect(drawEnv, ToolCircle._startx, ToolCircle._starty, drawEnv.x, y, fillFlag)

    // Clone and scale to edit Canvas
    drawEnv.updateEditCanvasFromSelectedPreviewCanvas()
  },

  handleMouseUp(drawEnv) {
    ToolCircle._storedPreviewImageData = null
    ToolCircle._startx = null
    ToolCircle._starty = null
  },

  handleMouseLeave(drawEnv) {
    // Treat as cancel:
    // drawEnv.previewCtx.clearRect(0,0, drawEnv.width, drawEnv.height)
    // drawEnv.previewCtx.putImageData(toolMove._storedPreviewImageData, 0, 0)
    ToolCircle.handleMouseUp()
  },
}

export default ToolCircle

function drawHorizLine(drawEnv, x1, x2, y, fillFlag = false) {
  if (x1 > x2) {
    const tmp = x1
    x1 = x2
    x2 = tmp
  }

  if (fillFlag) {
    while (x1 <= x2) {
      if (
        x1 >= -1 &&
        y >= -1 // Tiny bit easy perf tweak. Could do for right/bottom if important. -1 because of Math.round
      )
        drawEnv.setPreviewPixelsAt(x1, y)
      x1 = x1 + 1
    }
  } else {
    drawEnv.setPreviewPixelsAt(x1, y)
    drawEnv.setPreviewPixelsAt(x2, y)
  }
}

// Ellipse algorithm from http://members.chello.at/~easyfilter/bresenham.html
function drawEllipseRect(drawEnv, x0, y0, x1, y1, fillFlag = false) {
  let a = Math.abs(x1 - x0)
  let b = Math.abs(y1 - y0)
  let b1 = b & 1 // values of diameter
  let dx = 4 * (1 - a) * b * b,
    dy = 4 * (b1 + 1) * a * a // error increment
  let err = dx + dy + b1 * a * a // error of 1.step
  let e2 = 0

  if (x0 > x1) {
    // Swap points if necessary
    x0 = x1
    x1 += a
  }

  if (y0 > y1) y0 = y1 // exchange y if necessary

  y0 += (b + 1) / 2
  y1 = y0 - b1 // starting pixel
  a *= 8 * a
  b1 = 8 * b * b

  do {
    drawHorizLine(drawEnv, x0, x1, y0, fillFlag)
    drawHorizLine(drawEnv, x0, x1, y1, fillFlag)
    e2 = 2 * err
    if (e2 <= dy) {
      // calculate y-step
      y0++
      y1--
      err += dy += a
    }
    if (e2 >= dx || 2 * err > dy) {
      // calculate x-step
      x0++
      x1--
      err += dx += b1
    }
  } while (x0 <= x1)

  while (y0 - y1 < b) {
    // Handle case of too-early stop of flat ellipses a=1
    drawHorizLine(drawEnv, x0 - 1, x1 + 1, y0++)
    drawHorizLine(drawEnv, x0 - 1, x1 + 1, y1--)
  }
}
