const ToolRect = {
  label: 'Rectangle',
  name: 'rectTool',
  tooltip:
    'Click and drag to draw a rectangle. Use SHIFT+drag for filled rectangle. Use CTRL+drag to constrain to square.',
  icon: 'square icon', // Semantic-UI icon CSS class
  editCursor: 'crosshair',
  supportsDrag: true,
  shortcut: 'r',
  changesImage: true, // This does cause changes to the image, so image is dirty if this tool used
  level: 8,

  handleMouseDown: drawEnv => {
    // drawEnv is in the format generated by EditGraphic.collateDrawingToolEnv()

    ToolRect._storedPreviewImageData = drawEnv.previewCtx.getImageData(0, 0, drawEnv.width, drawEnv.height)
    ToolRect._startx = drawEnv.x
    ToolRect._starty = drawEnv.y
  },

  handleMouseMove: drawEnv => {
    let w = drawEnv.x - ToolRect._startx
    let h = drawEnv.y - ToolRect._starty
    const fillFlag = drawEnv.event.shiftKey === true
    const squareFlag = drawEnv.event.ctrlKey === true
    if (squareFlag) h = Math.abs(w) * Math.sign(h)

    // reset the preview canvas to how it was at MouseDown
    drawEnv.previewCtx.putImageData(ToolRect._storedPreviewImageData, 0, 0)

    // Draw a rectangle here
    drawRect(drawEnv, ToolRect._startx + w / 2, ToolRect._starty + h / 2, w / 2, h / 2, fillFlag)

    // Clone and scale to edit Canvas
    drawEnv.updateEditCanvasFromSelectedPreviewCanvas()
  },

  handleMouseUp: drawEnv => {
    ToolRect._storedPreviewImageData = null
    ToolRect._startx = null
    ToolRect._starty = null
  },

  handleMouseLeave: drawEnv => {
    // Treat as cancel:
    // drawEnv.previewCtx.clearRect(0,0, drawEnv.width, drawEnv.height)
    // drawEnv.previewCtx.putImageData(toolMove._storedPreviewImageData, 0, 0)
    ToolRect.handleMouseUp()
  },
}

export default ToolRect

function drawHorizLine(drawEnv, x1, x2, y, fillFlag = false) {
  if (x1 > x2) {
    const tmp = x1
    x1 = x2
    x2 = tmp
  }

  if (fillFlag) {
    while (x1 <= x2) {
      if (
        x1 >= -1 &&
        y >= -1 // Tiny bit easy perf tweak. Could do for right/bottom if important. -1 because of Math.round
      )
        drawEnv.setPreviewPixelsAt(x1, y)
      x1 = x1 + 1
    }
  } else {
    drawEnv.setPreviewPixelsAt(x1, y)
    drawEnv.setPreviewPixelsAt(x2, y)
  }
}

// x0, y0 are center of rectangle
// h is half-height; w is half-width (i.e. center to edge)
function drawRect(drawEnv, x0, y0, w, h, fillFlag = false) {
  h = Math.abs(h)
  w = Math.abs(w)

  for (let j = -h; j <= h; j++) {
    drawHorizLine(drawEnv, x0 - w, x0 + w, y0 + j, Math.abs(j) === h ? true : fillFlag)
  }
}
