import _ from 'lodash'
import { Chats } from '/imports/schemas'
import { chatParams, parseChannelName, isChannelNameWellFormed, chatsSchema, currUserCanSend } from '/imports/schemas/chats'
import { check,  } from 'meteor/check'
import { lookupIsUseridInProject } from '/imports/schemas/projects-server'

/**
 * This function calls lookupIsUseridInProject() so it is server-side only
 * 
 * @param {any} currUser
 * @param {any} channelName
 * @returns {Boolean} true if the user can send to this channel
 */
function canUserReallySendToChannel(currUser, channelName)
{
  // This is a leaky access check that is used mostly on the client
  const canSend = currUserCanSend(currUser, channelName)
  if (!canSend)
    return false

  // Now to look for the cases that currUserCanSend() isn't smart about
  const channelObj = parseChannelName(channelName)
  // Access check for publication of channels
  switch (channelObj.scopeGroupName)
  {
  case 'Global':
    return true // It was checked for admin etc in currUserCanSend()

  case 'Project':
    return lookupIsUseridInProject(currUser._id, channelObj.scopeId)

  case 'Asset':
  case 'User':
  case 'DirectMessage':
  default:
    console.log(`Unhandled scopeGroupName ${channelObj.scopeGroupName} in canUserReallySendToChannel()`)
    return false
  }
}


Meteor.methods({

  /** Chats.send
   *  @param {string} channelName - A channelName generated by makeChannelName()
   *                      according to it's described constraints
   *  @param {string} message - the message to be sent (TBD on validation)
   * 
   */
  "Chats.send": function(channelName, message, chatMetadata) {
    if (!this.userId)
      throw new Meteor.Error(401, "Login required")

    if (!message || message.length < 1)
      throw new Meteor.Error(400, "Message empty")

    if (message.length > chatParams.maxChatMessageTextLen)
      throw new Meteor.Error(400, "Message too long")

    if (!isChannelNameWellFormed(channelName))
      throw new Meteor.Error(400, `Channel name '${channelName}' is not in the expected format`)

    const data = { 
      toChannelName: channelName,
      message:       _.trim(message)
    }

    const currUser = Meteor.user()
    if (!canUserReallySendToChannel(currUser, channelName))
      throw new Meteor.Error(401, "No access to write to that channel")

    const now = new Date()
    data.createdAt = now
    data.updatedAt = now
    data.byUserId = this.userId
    data.byUserName = currUser.profile.name
    check(data, _.omit(chatsSchema, '_id'))

    let docId = Chats.insert(data)
    if (Meteor.isServer)
    {
      console.log(`  [Chats.send]  "${data.message}"  #${docId}  `)
      Meteor.call('Slack.Chats.send', currUser.profile.name, data.message, data.toChannelName)
    }
    return docId
  }
})

// if (Meteor.isServer)
// {
//   Meteor.methods({
//     'dgolds.migrateChatDB': function(isForRealz) {
//       if (!this.userId)
//         throw new Meteor.Error(401, "Login required")
//       if (Meteor.user().username !== 'dgolds')
//         throw new Meteor.Error(401, "You do not have the power")
//       console.log("ONLY you have The Power")

//       const GenKEY = 'GENERAL'
//       const theOldChannelName=ChatChannels[GenKEY].name
//       const sel= { toChannelName: theOldChannelName}
//       const count = Chats.find(sel).count()
//       const newChanName = ChatChannels[GenKEY].channelName
//       console.log(`${count} rows of '${sel.toChannelName}' to change to '${newChanName}'`)

//       if (isForRealz === true)
//         Chats.update( 
//           sel, 
//           { $set: { toChannelName: newChanName} }, 
//           { multi: true }
//         )
//       console.log('KTHXBYE')
//     }
//   })
// }