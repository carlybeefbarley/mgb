{
  "mole1": {
    "steps": [
      {
        "text": "This tutorial is based on a very simple game - \"Whack a Mole\". The game has 9 holes where moles can appear randomly. You have to be fast and hit the mole before it moves to another hole. <br/><br/>At first we need to import Phaser framework. It will help us write game much faster and with less effort because a lot of common game code is already written there.",
        "code": "import 'phaser'", 
        "highlight": [
          { "from": 1, "to": 2 }
        ]
      },
      {
        "text": "Then we define Phaser game object. First two parameters defines dimension of game, third is about renderer (leave it to auto). 4th is parent container which will always be ‘game’ in MGB. The last parameter is predefined function set which we will created afterwards",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(510, 600, Phaser.AUTO, 'game', { preload: preload, create: create })", 
        "highlight": [
          { "from": 3, "to": 3 }
        ]
      },
      {
        "text": "<b>Preload function</b> - all game assets are loaded here. This function is called before any other function",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(510, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n\n}", 
        "highlight": [
          { "from": 5, "to": 7 }
        ]
      },
      {
        "text": "<b>Create function</b>. This function is called when all game assets are loaded. Here we can start to build an actual game",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(510, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n\n}\n\nfunction create() {\n\n}", 
        "highlight": [
          { "from": 9, "to": 11 }
        ]
      },
      {
        "text": "Lets draw a mole on screen. We need to preload mole graphic with game.load.image method. The first parameter is graphic name and second is an url which you can get in MGB graphic editor. After asset loading create function is called and here we draw a sprite with game.add.sprite method. First two parameters defines position on the screen (starting from top left corner.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(510, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n  game.load.image('mole', '/api/asset/png/dWZ3YsxzBWE787AKu') \n}\n\nfunction create(){\n  game.add.sprite(100, 100, 'mole') \n}", 
        "highlight": [
          { "from": 6, "to": 6 },
          { "from": 10, "to": 10 }
        ]
      },
      {
        "text": "Now the basic concept is clear. Lets preload all assets so we don’t have to worry about them later. We have: mole, mole_hit, background graphics and mole_hit sound. Note that sound is loaded with game.load.sound method",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(510, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n  game.load.image('background','/api/asset/png/u7Z5S6u8cQB7ipeTp')\n  game.load.image('mole','/api/asset/png/dWZ3YsxzBWE787AKu')\n  game.load.image('mole_hit','/api/asset/png/aMtFxfuumkYnwFQta')\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nfunction create() {\n  game.add.sprite(100, 100, 'mole')\n}", 
        "highlight": [
          { "from": 7, "to": 9 }
        ]
      },
      {
        "text": "Lets add background and functionality for mole to change position after 700 miliseconds. At first we define global mole variable <code>let mole</code> and in create function assign it to sprite. After that we define our own function <code>moleAppear</code> which randomly positions mole on the holes. game.rnd.integerInRange method returns integer which is a row and column number in 3x3 grid. We assign x and y properties to mole reference by multiplying column with hole width and row with hole height plus offset. At the end we use <code>setInterval</code> function to call <code>moleAppear</code> in 700ms intervals. Check it out by running the code.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(510, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n  game.load.image('background','/api/asset/png/u7Z5S6u8cQB7ipeTp')\n  game.load.image('mole','/api/asset/png/dWZ3YsxzBWE787AKu')\n  game.load.image('mole_hit','/api/asset/png/aMtFxfuumkYnwFQta')\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole \n\nfunction create() {\n  game.add.sprite(0, 0, 'background')\n  mole = game.add.sprite(0, -999, 'mole')\n  setInterval(moleAppear, 700)\n}\n\nfunction moleAppear(){\n  mole.x = game.rnd.integerInRange(0, 2) * 170\n  mole.y = game.rnd.integerInRange(0, 2) * 140 + 138\n}", 
        "highlight": [
          { "from": 12, "to": 12 },
          { "from": 16, "to": 17 },
          { "from": 20, "to": 23 }
        ]
      },
      {
        "text": "Now we need to make hit functionality. At the end of <code>create</code> function put two lines of code. First one enables input for the mole sprite. Second one tracks onInputDown event (mouse click or touch) and triggers <code>moleHit</code> function. To check if you really clicked the mole - you need output - console.log writes message in console field under the game screen",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(510, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n  game.load.image('background','/api/asset/png/u7Z5S6u8cQB7ipeTp')\n  game.load.image('mole','/api/asset/png/dWZ3YsxzBWE787AKu')\n  game.load.image('mole_hit','/api/asset/png/aMtFxfuumkYnwFQta')\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole \n\nfunction create() {\n  game.add.sprite(0, 0, 'background')\n  mole = game.add.sprite(0, -999, 'mole')\n  setInterval(moleAppear, 700)\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n}\n\nfunction moleAppear(){\n  mole.x = game.rnd.integerInRange(0, 2) * 170\n  mole.y = game.rnd.integerInRange(0, 2) * 140 + 138\n}\n\nfunction moleHit(){\n  console.log('mole hit!')\n}", 
        "highlight": [
          { "from": 18, "to": 19 }
        ]
      },
      {
        "text": "The problem we face is that player can click on the mole several times. We should allow only one click per appearance. To avoid this we declare a global variable <code>isHit</code>. On each hit set variable to true and on next hit ignore returning from function. Meanwhile we are indicating mole hit by changing it’s texture with ‘loadTexture’ method. On each mole appearance ‘isHit’ variable and texture resets",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(510, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n  game.load.image('background','/api/asset/png/u7Z5S6u8cQB7ipeTp')\n  game.load.image('mole','/api/asset/png/dWZ3YsxzBWE787AKu')\n  game.load.image('mole_hit','/api/asset/png/aMtFxfuumkYnwFQta')\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole\nlet isHit = false \n\nfunction create() {\n  game.add.sprite(0, 0, 'background')\n  mole = game.add.sprite(0, -999, 'mole')\n  setInterval(moleAppear, 700)\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.loadTexture('mole')\n  }\n  mole.x = game.rnd.integerInRange(0, 2) * 170\n  mole.y = game.rnd.integerInRange(0, 2) * 140 + 138\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.loadTexture('mole_hit')\n}", 
        "highlight": [
          { "from": 13, "to": 13 },
          { "from": 24, "to": 27 }
        ]
      },
      {
        "text": "The last thing we need to complete basic game is a little point counter which shows mole hit count. Two additional global variables are declared for point storing and referencing text object. In create function add text with <code>game.add.text</code> method. Text value is changed by <code>setText</code> method",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(510, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n  game.load.image('background','/api/asset/png/u7Z5S6u8cQB7ipeTp')\n  game.load.image('mole','/api/asset/png/dWZ3YsxzBWE787AKu')\n  game.load.image('mole_hit','/api/asset/png/aMtFxfuumkYnwFQta')\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \n\nfunction create() {\n  game.add.sprite(0, 0, 'background')\n  mole = game.add.sprite(0, -999, 'mole')\n  setInterval(moleAppear, 700)\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.loadTexture('mole')\n  }\n  mole.x = game.rnd.integerInRange(0, 2) * 170\n  mole.y = game.rnd.integerInRange(0, 2) * 140 + 138\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.loadTexture('mole_hit')\n  hitCount++\n  pointsText.setText(hitCount) \n}", 
        "highlight": [
          { "from": 14, "to": 15 },
          { "from": 24, "to": 26 },
          { "from": 42, "to": 43 }
        ]
      }
    ]
  },



  "mole2": {
    "steps": [
      {
        "text": "Lets start from the code of first part. Our task is to add nice animations for mole. So we will introduce to you such concepts ar tweens, spritesheets and layers.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(510, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n  game.load.image('background','/api/asset/png/u7Z5S6u8cQB7ipeTp')\n  game.load.image('mole','/api/asset/png/dWZ3YsxzBWE787AKu')\n  game.load.image('mole_hit','/api/asset/png/aMtFxfuumkYnwFQta')\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \n\nfunction create() {\n  game.add.sprite(0, 0, 'background')\n  mole = game.add.sprite(0, -999, 'mole')\n  setInterval(moleAppear, 700)\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.loadTexture('mole')\n  }\n  mole.x = game.rnd.integerInRange(0, 2) * 170\n  mole.y = game.rnd.integerInRange(0, 2) * 140 + 138\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.loadTexture('mole_hit')\n  hitCount++\n  pointsText.setText(hitCount) \n}"
      },
      {
        "text": "We are getting rid from static background and are creating image from hole pictures. They will be grouped <code>game.add.group()</code> on top and under mole sprite. The first layer goes on very bottom of the screen.<br/><br/>Inside two <code>for</code> loops we are placing hole sprites as background elements.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n  game.load.image('mole','/api/asset/png/dWZ3YsxzBWE787AKu')\n  game.load.image('mole_hit','/api/asset/png/aMtFxfuumkYnwFQta')\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  setInterval(moleAppear, 700)\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = 54\n  holeGroup2.y = 54\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * 146\n      let y = row * 182\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.loadTexture('mole')\n  }\n  mole.x = game.rnd.integerInRange(0, 2) * 146\n  mole.y = game.rnd.integerInRange(0, 2) * 182 + 54\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.loadTexture('mole_hit')\n  hitCount++\n  pointsText.setText(hitCount) \n}", 
        "highlight": [
          { "from": 6, "to": 7 },
          { "from": 19, "to": 20 },
          { "from": 27, "to": 40 }
        ]
      },
      {
        "text": "Game code has lot of hardcoded numbers which is not a godd practice in our development. Much better is to create such variables as <code>HOLE_WIDTH</code>, <code>HOLE_HEIGHT</code>, <code>OFFSET_Y</code> and place them instead of those numbers. If something changes then there will be only one place where to correct changes.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n  game.load.image('mole','/api/asset/png/dWZ3YsxzBWE787AKu')\n  game.load.image('mole_hit','/api/asset/png/aMtFxfuumkYnwFQta')\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  setInterval(moleAppear, 700)\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.loadTexture('mole')\n  }\n  mole.x = game.rnd.integerInRange(0, 2) * HOLE_WIDTH\n  mole.y = game.rnd.integerInRange(0, 2) * HOLE_HEIGHT + OFFSET_Y\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.loadTexture('mole_hit')\n  hitCount++\n  pointsText.setText(hitCount) \n}", 
        "highlight": [
          { "from": 17, "to": 17 },
          { "from": 29, "to": 30 },
          { "from": 36, "to": 37 },
          { "from": 53, "to": 54 }
        ]
      },
      {
        "text": "<b>Tweens</b>. At first we will create a simple tween animation. Lets make <code>gameTitle</code> and add a tween to it. Note that you need to define <code>.to()</code> and <code>.start()</code> methods. Inside <code>.to()</code> method define parameters: new state (position, alpha, etc), animation time and animation type (linear is the default one).",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n  game.load.image('mole','/api/asset/png/dWZ3YsxzBWE787AKu')\n  game.load.image('mole_hit','/api/asset/png/aMtFxfuumkYnwFQta')\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  setInterval(moleAppear, 700)\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.loadTexture('mole')\n  }\n  mole.x = game.rnd.integerInRange(0, 2) * HOLE_WIDTH\n  mole.y = game.rnd.integerInRange(0, 2) * HOLE_HEIGHT + OFFSET_Y\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.loadTexture('mole_hit')\n  hitCount++\n  pointsText.setText(hitCount) \n}",
        "highlight": [
          { "from": 47, "to": 52 }
        ]
      },
      {
        "text": "For mole sprite we are creating more complicated animation where multiple <code>.to()</code> methods are added. <code>Quart.easeOut</code> animation type makes animation faster at start and slower at the end so it looks more natural.<br/><br/>Note that we improved random position of mole. Now we use <code>do {} while ()</code> structure to make sure that mole would not appear at the same place twice in a row.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n  game.load.image('mole','/api/asset/png/dWZ3YsxzBWE787AKu')\n  game.load.image('mole_hit','/api/asset/png/aMtFxfuumkYnwFQta')\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\nconst molePosition = { col: -1, row: -1 }\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  setInterval(moleAppear, 700)\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.loadTexture('mole')\n  }\n  \n  // set mole position randomly, but don't allow appear in same spot twice\n  let newCol, newRow\n  do {\n    newCol = game.rnd.integerInRange(0, 2)\n    newRow = game.rnd.integerInRange(0, 2)\n  }\n  while (molePosition.col == newCol && molePosition.row == newRow)\n\n  molePosition.col = newCol\n  molePosition.row = newRow\n\n  let x = molePosition.col * HOLE_WIDTH\n  let y = molePosition.row * HOLE_HEIGHT + OFFSET_Y\n  mole.x = x\n  mole.y = y + 80\n\n  game.add.tween(mole)\n    .to( {y: y}, 300, 'Quart.easeOut')\n    .to( {y: y}, 200, 'Quart.easeOut')\n    .to( {y: y + 80}, 300, 'Quart.easeOut')\n    .start()\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.loadTexture('mole_hit')\n  hitCount++\n  pointsText.setText(hitCount) \n}",
        "highlight": [
          { "from": 18, "to": 18 },
          { "from": 62, "to": 82 }
        ]
      },
      {
        "text": "<b>Spritesheets</b>. As a last improvement we are using spritesheet for mole. Basically sprite sheet is an image with two frames and we load it via <code>game.load.spritesheet()</code> instead of <code>game.load.image()</code>. Also there are two parameters <code>146, 182</code> which define frame width and height. To change frame we simply use <code>mole.frame = frameNumber</b> where frameNumber is 0 or 1 in our case.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n    // mole.frame=0 - regular mole; mole.frame=1 - hit mole\n  game.load.spritesheet('mole', '/api/asset/tileset/Nk55mERMWof92Rj9X', 146, 182)\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\nconst molePosition = { col: -1, row: -1 }\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  setInterval(moleAppear, 700)\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.frame = 0\n  }\n  \n  // set mole position randomly, but don't allow appear in same spot twice\n  let newCol, newRow\n  do {\n    newCol = game.rnd.integerInRange(0, 2)\n    newRow = game.rnd.integerInRange(0, 2)\n  }\n  while (molePosition.col == newCol && molePosition.row == newRow)\n\n  molePosition.col = newCol\n  molePosition.row = newRow\n\n  let x = molePosition.col * HOLE_WIDTH\n  let y = molePosition.row * HOLE_HEIGHT + OFFSET_Y\n  mole.x = x\n  mole.y = y + 80\n\n  game.add.tween(mole)\n    .to( {y: y}, 300, 'Quart.easeOut')\n    .to( {y: y}, 200, 'Quart.easeOut')\n    .to( {y: y + 80}, 300, 'Quart.easeOut')\n    .start()\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.frame = 1\n  hitCount++\n  pointsText.setText(hitCount) \n}",
        "highlight": [
          { "from": 8, "to": 9 },
          { "from": 88, "to": 88 },
          { "from": 59, "to": 59 }
        ]
      }
    ]
  },


  "mole3": {
    "steps": [
      {
        "text": "Lets start from the code of second part. Our task is to change timing so by game progressing it is harder to hit the mole. For this we will introduce you <code>update()</code> function.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n    // mole.frame=0 - regular mole; mole.frame=1 - hit mole\n  game.load.spritesheet('mole', '/api/asset/tileset/Nk55mERMWof92Rj9X', 146, 182)\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\nconst molePosition = { col: -1, row: -1 }\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  setInterval(moleAppear, 700)\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.frame = 0\n  }\n  \n  // set mole position randomly, but don't allow appear in same spot twice\n  let newCol, newRow\n  do {\n    newCol = game.rnd.integerInRange(0, 2)\n    newRow = game.rnd.integerInRange(0, 2)\n  }\n  while (molePosition.col == newCol && molePosition.row == newRow)\n\n  molePosition.col = newCol\n  molePosition.row = newRow\n\n  let x = molePosition.col * HOLE_WIDTH\n  let y = molePosition.row * HOLE_HEIGHT + OFFSET_Y\n  mole.x = x\n  mole.y = y + 80\n\n  game.add.tween(mole)\n    .to( {y: y}, 300, 'Quart.easeOut')\n    .to( {y: y}, 200, 'Quart.easeOut')\n    .to( {y: y + 80}, 300, 'Quart.easeOut')\n    .start()\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.frame = 1\n  hitCount++\n  pointsText.setText(hitCount) \n}"
      },
      {
        "text": "<b>update function</b> is another build in function in Phaser which calls automatically 60 times a second. In game development world it is often called as <b>game loop</b>. This construction helps us handle timing events more precisely than <code>setInterval()</code><br/><br/>. To set up udpate we need to pass function variable in game creation line <code>new Phaser.Game()</code> and create the function itself. Run the game and see console output.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create, update: update })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n    // mole.frame=0 - regular mole; mole.frame=1 - hit mole\n  game.load.spritesheet('mole', '/api/asset/tileset/Nk55mERMWof92Rj9X', 146, 182)\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\nconst molePosition = { col: -1, row: -1 }\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n}\n\n// calls 60 times a second\nfunction update(){\n  console.log(game.time.totalElapsedSeconds())\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.frame = 0\n  }\n  \n  // set mole position randomly, but don't allow appear in same spot twice\n  let newCol, newRow\n  do {\n    newCol = game.rnd.integerInRange(0, 2)\n    newRow = game.rnd.integerInRange(0, 2)\n  }\n  while (molePosition.col == newCol && molePosition.row == newRow)\n\n  molePosition.col = newCol\n  molePosition.row = newRow\n\n  let x = molePosition.col * HOLE_WIDTH\n  let y = molePosition.row * HOLE_HEIGHT + OFFSET_Y\n  mole.x = x\n  mole.y = y + 80\n\n  game.add.tween(mole)\n    .to( {y: y}, 300, 'Quart.easeOut')\n    .to( {y: y}, 200, 'Quart.easeOut')\n    .to( {y: y + 80}, 300, 'Quart.easeOut')\n    .start()\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.frame = 1\n  hitCount++\n  pointsText.setText(hitCount) \n}",
        "highlight": [
          { "from": 3, "to": 3 },
          { "from": 56, "to": 58 }
        ]
      },
      {
        "text": "Now we'll add some functionality in the game loop. Note two new variables: <code>lastAppear</code>, <code>appearDuration</code> which we are using to calculate time and decrease mole appearance duration so game becomes harder.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create, update: update })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n    // mole.frame=0 - regular mole; mole.frame=1 - hit mole\n  game.load.spritesheet('mole', '/api/asset/tileset/Nk55mERMWof92Rj9X', 146, 182)\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\nconst molePosition = { col: -1, row: -1 }\nlet lastAppear=0, appearDuration = 1000 // both values in miliseconds\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n}\n\n// calls 60 times a second\nfunction update(){\n  const currentTimeMS = Math.round(game.time.totalElapsedSeconds() * 1000) // from ms to second\n  if(currentTimeMS - lastAppear >= appearDuration){\n    // with each appearance game gets 10ms faster\n    appearDuration -= 10\n    console.log('appearDuration', appearDuration)\n    lastAppear = currentTimeMS\n    moleAppear()\n  }\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.frame = 0\n  }\n  \n  // set mole position randomly, but don't allow appear in same spot twice\n  let newCol, newRow\n  do {\n    newCol = game.rnd.integerInRange(0, 2)\n    newRow = game.rnd.integerInRange(0, 2)\n  }\n  while (molePosition.col == newCol && molePosition.row == newRow)\n\n  molePosition.col = newCol\n  molePosition.row = newRow\n\n  let x = molePosition.col * HOLE_WIDTH\n  let y = molePosition.row * HOLE_HEIGHT + OFFSET_Y\n  mole.x = x\n  mole.y = y + 80\n  mole.alpha = 1\n\n  tween = game.add.tween(mole)\n    .to( { y: y }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( { y: y }, Math.round(appearDuration*0.2), 'Quart.easeOut')\n   .to( { y: y+80 }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( {alpha: 0}, 100, 'Quart.easeOut' )\n   .start()\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.frame = 1\n  hitCount++\n  pointsText.setText(hitCount) \n}",
        "highlight": [
          { "from": 19, "to": 19 },
          { "from": 58, "to": 65 }
        ]
      },
      {
        "text": "At last we put if check in <code>update</code> function to stop game when <code>appearTime</code> becomes 500 milliseconds.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create, update: update })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n    // mole.frame=0 - regular mole; mole.frame=1 - hit mole\n  game.load.spritesheet('mole', '/api/asset/tileset/Nk55mERMWof92Rj9X', 146, 182)\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\nconst molePosition = { col: -1, row: -1 }\nlet lastAppear=0, appearDuration = 1000 // both values in miliseconds\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n}\n\n// calls 60 times a second\nfunction update(){\n  // game finishes when mole appears too fast for player to react\n  if(appearDuration <= 500){\n    console.log('game paused')\n    // pause entire game\n    game.paused = true\n  }\n  \n  const currentTimeMS = Math.round(game.time.totalElapsedSeconds() * 1000) // from ms to second\n  if(currentTimeMS - lastAppear >= appearDuration){\n    // with each appearance game gets 10ms faster\n    appearDuration -= 10\n    console.log('appearDuration', appearDuration)\n    lastAppear = currentTimeMS\n    moleAppear()\n  }\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.frame = 0\n  }\n  \n  // set mole position randomly, but don't allow appear in same spot twice\n  let newCol, newRow\n  do {\n    newCol = game.rnd.integerInRange(0, 2)\n    newRow = game.rnd.integerInRange(0, 2)\n  }\n  while (molePosition.col == newCol && molePosition.row == newRow)\n\n  molePosition.col = newCol\n  molePosition.row = newRow\n\n  let x = molePosition.col * HOLE_WIDTH\n  let y = molePosition.row * HOLE_HEIGHT + OFFSET_Y\n  mole.x = x\n  mole.y = y + 80\n  mole.alpha = 1\n\n  tween = game.add.tween(mole)\n    .to( { y: y }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( { y: y }, Math.round(appearDuration*0.2), 'Quart.easeOut')\n   .to( { y: y+80 }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( {alpha: 0}, 100, 'Quart.easeOut' )\n   .start()\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.frame = 1\n  hitCount++\n  pointsText.setText(hitCount) \n}",
        "highlight": [
          { "from": 58, "to": 63 }
        ]
      }
    ]
  },



  "mole4": {
    "steps": [
      {
        "text": "Lets start from the code of third part. Our task is to add user interface for game. There will be start and end screens and option to replay the game.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create, update: update })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n    // mole.frame=0 - regular mole; mole.frame=1 - hit mole\n  game.load.spritesheet('mole', '/api/asset/tileset/Nk55mERMWof92Rj9X', 146, 182)\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\nconst molePosition = { col: -1, row: -1 }\nlet lastAppear=0, appearDuration = 1000 // both values in miliseconds\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n}\n\n// calls 60 times a second\nfunction update(){\n  // game finishes when mole appears too fast for player to react\n  if(appearDuration <= 500){\n    console.log('game paused')\n    // pause entire game\n    game.paused = true\n  }\n  \n  const currentTimeMS = Math.round(game.time.totalElapsedSeconds() * 1000) // from ms to second\n  if(currentTimeMS - lastAppear >= appearDuration){\n    // with each appearance game gets 10ms faster\n    appearDuration -= 10\n    console.log('appearDuration', appearDuration)\n    lastAppear = currentTimeMS\n    moleAppear()\n  }\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.frame = 0\n  }\n  \n  // set mole position randomly, but don't allow appear in same spot twice\n  let newCol, newRow\n  do {\n    newCol = game.rnd.integerInRange(0, 2)\n    newRow = game.rnd.integerInRange(0, 2)\n  }\n  while (molePosition.col == newCol && molePosition.row == newRow)\n\n  molePosition.col = newCol\n  molePosition.row = newRow\n\n  let x = molePosition.col * HOLE_WIDTH\n  let y = molePosition.row * HOLE_HEIGHT + OFFSET_Y\n  mole.x = x\n  mole.y = y + 80\n  mole.alpha = 1\n\n  tween = game.add.tween(mole)\n    .to( { y: y }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( { y: y }, Math.round(appearDuration*0.2), 'Quart.easeOut')\n   .to( { y: y+80 }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( {alpha: 0}, 100, 'Quart.easeOut' )\n   .start()\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.frame = 1\n  hitCount++\n  pointsText.setText(hitCount) \n}",
        "highlight": [
          { "from": 0, "to": 0}
        ]
      },
      {
        "text": "Lets add popup background and buttons. Also define variables we will need in the future.<br/><br/>Note on line 62 that we disabled automatic game start.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create, update: update })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n    // mole.frame=0 - regular mole; mole.frame=1 - hit mole\n  game.load.spritesheet('mole', '/api/asset/tileset/Nk55mERMWof92Rj9X', 146, 182)\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n  game.load.image('popup', '/api/asset/png/6rfeqF2JXEz3FwSiB')\n  // frames: 0=easy, 1=medium, 2=hard, 3=repeat\n  game.load.spritesheet('buttons', '/api/asset/tileset/7BoHNs7wDsEczqshQ', 150, 38)\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\nconst molePosition = { col: -1, row: -1 }\nlet lastAppear=0, appearDuration = 1000 // both values in miliseconds\nlet uiGroup, startPopup, endPopup\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n}\n\n// calls 60 times a second\nfunction update(){\n  // game finishes when mole appears too fast for player to react\n  if(appearDuration <= 500){\n    console.log('game paused')\n    // pause entire game\n    game.paused = true\n  }\n  \n  const currentTimeMS = Math.round(game.time.totalElapsedSeconds() * 1000) // from ms to second\n  if(currentTimeMS - lastAppear >= appearDuration){\n    // with each appearance game gets 10ms faster\n    appearDuration -= 10\n    console.log('appearDuration', appearDuration)\n    lastAppear = currentTimeMS\n    moleAppear()\n  }\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.frame = 0\n  }\n  \n  // set mole position randomly, but don't allow appear in same spot twice\n  let newCol, newRow\n  do {\n    newCol = game.rnd.integerInRange(0, 2)\n    newRow = game.rnd.integerInRange(0, 2)\n  }\n  while (molePosition.col == newCol && molePosition.row == newRow)\n\n  molePosition.col = newCol\n  molePosition.row = newRow\n\n  let x = molePosition.col * HOLE_WIDTH\n  let y = molePosition.row * HOLE_HEIGHT + OFFSET_Y\n  mole.x = x\n  mole.y = y + 80\n  mole.alpha = 1\n\n  tween = game.add.tween(mole)\n    .to( { y: y }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( { y: y }, Math.round(appearDuration*0.2), 'Quart.easeOut')\n   .to( { y: y+80 }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( {alpha: 0}, 100, 'Quart.easeOut' )\n   .start()\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.frame = 1\n  hitCount++\n  pointsText.setText(hitCount) \n}",
        "highlight": [
          { "from": 62, "to": 63},
          { "from": 11, "to": 13},
          { "from": 23, "to": 23}
        ]
      },
      {
        "text": "First UI element is a start popup. We are creating it as a group which contains background and level buttons. For now we will also define an empty <code>selectLevel</code> function where we will set up a level.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create, update: update })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n    // mole.frame=0 - regular mole; mole.frame=1 - hit mole\n  game.load.spritesheet('mole', '/api/asset/tileset/Nk55mERMWof92Rj9X', 146, 182)\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n  game.load.image('popup', '/api/asset/png/6rfeqF2JXEz3FwSiB')\n  // frames: 0=easy, 1=medium, 2=hard, 3=repeat\n  game.load.spritesheet('buttons', '/api/asset/tileset/7BoHNs7wDsEczqshQ', 150, 38)\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\nconst molePosition = { col: -1, row: -1 }\nlet lastAppear=0, appearDuration = 1000 // both values in miliseconds\nlet uiGroup, startPopup, endPopup\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n  \n  drawStartPopup()\n}\n\n// calls 60 times a second\nfunction update(){\n  // wait till user selects level and starts the game\n  if(lastAppear === 0) return;\n  \n  // game finishes when mole appears too fast for player to react\n  if(appearDuration <= 500){\n    console.log('game paused')\n    // pause entire game\n    game.paused = true\n  }\n  \n  const currentTimeMS = Math.round(game.time.totalElapsedSeconds() * 1000) // from ms to second\n  if(currentTimeMS - lastAppear >= appearDuration){\n    // with each appearance game gets 10ms faster\n    appearDuration -= 10\n    console.log('appearDuration', appearDuration)\n    lastAppear = currentTimeMS\n    moleAppear()\n  }\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.frame = 0\n  }\n  \n  // set mole position randomly, but don't allow appear in same spot twice\n  let newCol, newRow\n  do {\n    newCol = game.rnd.integerInRange(0, 2)\n    newRow = game.rnd.integerInRange(0, 2)\n  }\n  while (molePosition.col == newCol && molePosition.row == newRow)\n\n  molePosition.col = newCol\n  molePosition.row = newRow\n\n  let x = molePosition.col * HOLE_WIDTH\n  let y = molePosition.row * HOLE_HEIGHT + OFFSET_Y\n  mole.x = x\n  mole.y = y + 80\n  mole.alpha = 1\n\n  tween = game.add.tween(mole)\n    .to( { y: y }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( { y: y }, Math.round(appearDuration*0.2), 'Quart.easeOut')\n   .to( { y: y+80 }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( {alpha: 0}, 100, 'Quart.easeOut' )\n   .start()\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.frame = 1\n  hitCount++\n  pointsText.setText(hitCount) \n}\n\nfunction drawStartPopup(){\n  const centerX = game.world.width/2\n  const centerY = game.world.height/2\n  startPopup = game.add.group(uiGroup, 'startPopup')\n  const bg = startPopup.create(centerX, centerY, 'popup')\n  bg.anchor.set(0.5, 0.5)\n  \n  const levels = ['easy', 'medium', 'hard']\n  levels.forEach((level, i) => {\n   const button = game.add.button(centerX, centerY-90 + i*50, 'buttons', ()=>selectLevel(level), null, i, i, i)\n   button.anchor.set(0.5, 0.5)\n   startPopup.add(button)\n  })\n}\n\nfunction selectLevel (level) {\n  console.log('selected level', level) \n}",
        "highlight": [
          { "from": 59, "to": 59},
          { "from": 123, "to": 136},
          { "from": 138, "to": 140}
        ]
      },
      {
        "text": "<code>selectLevel()</code> function is updated so selecting level will affect <code>appearDuration</code>.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create, update: update })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n    // mole.frame=0 - regular mole; mole.frame=1 - hit mole\n  game.load.spritesheet('mole', '/api/asset/tileset/Nk55mERMWof92Rj9X', 146, 182)\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n  game.load.image('popup', '/api/asset/png/6rfeqF2JXEz3FwSiB')\n  // frames: 0=easy, 1=medium, 2=hard, 3=repeat\n  game.load.spritesheet('buttons', '/api/asset/tileset/7BoHNs7wDsEczqshQ', 150, 38)\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\nconst molePosition = { col: -1, row: -1 }\nlet lastAppear=0, appearDuration = 1000 // both values in miliseconds\nlet uiGroup, startPopup, endPopup\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n  \n  drawStartPopup()\n}\n\n// calls 60 times a second\nfunction update(){\n  // wait till user selects level and starts the game\n  if(lastAppear === 0) return;\n  \n  // game finishes when mole appears too fast for player to react\n  if(appearDuration <= 500){\n    console.log('game paused')\n    // pause entire game\n    game.paused = true\n  }\n  \n  const currentTimeMS = Math.round(game.time.totalElapsedSeconds() * 1000) // from ms to second\n  if(currentTimeMS - lastAppear >= appearDuration){\n    // with each appearance game gets 10ms faster\n    appearDuration -= 10\n    console.log('appearDuration', appearDuration)\n    lastAppear = currentTimeMS\n    moleAppear()\n  }\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.frame = 0\n  }\n  \n  // set mole position randomly, but don't allow appear in same spot twice\n  let newCol, newRow\n  do {\n    newCol = game.rnd.integerInRange(0, 2)\n    newRow = game.rnd.integerInRange(0, 2)\n  }\n  while (molePosition.col == newCol && molePosition.row == newRow)\n\n  molePosition.col = newCol\n  molePosition.row = newRow\n\n  let x = molePosition.col * HOLE_WIDTH\n  let y = molePosition.row * HOLE_HEIGHT + OFFSET_Y\n  mole.x = x\n  mole.y = y + 80\n  mole.alpha = 1\n\n  tween = game.add.tween(mole)\n    .to( { y: y }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( { y: y }, Math.round(appearDuration*0.2), 'Quart.easeOut')\n   .to( { y: y+80 }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( {alpha: 0}, 100, 'Quart.easeOut' )\n   .start()\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.frame = 1\n  hitCount++\n  pointsText.setText(hitCount) \n}\n\nfunction drawStartPopup(){\n  const centerX = game.world.width/2\n  const centerY = game.world.height/2\n  startPopup = game.add.group(uiGroup, 'startPopup')\n  const bg = startPopup.create(centerX, centerY, 'popup')\n  bg.anchor.set(0.5, 0.5)\n  \n  const levels = ['easy', 'medium', 'hard']\n  levels.forEach((level, i) => {\n   const button = game.add.button(centerX, centerY-90 + i*50, 'buttons', ()=>selectLevel(level), null, i, i, i)\n   button.anchor.set(0.5, 0.5)\n   startPopup.add(button)\n  })\n}\n\nfunction selectLevel (level) {\n  startPopup.visible = false\n  switch(level){\n    case 'easy':\n      appearDuration = 1000\n      break;\n    case 'medium':\n      appearDuration = 900\n      break;\n    case 'hard':\n      appearDuration = 700\n      break;\n  }\n  lastAppear = Math.round(game.time.totalElapsedSeconds() * 1000)\n}",
        "highlight": [
          { "from": 139, "to": 151}
        ]
      },
      {
        "text": "<code>update()</code> function is changed so it doesn't pause game anymore. Instead we will call end popup in next step.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create, update: update })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n    // mole.frame=0 - regular mole; mole.frame=1 - hit mole\n  game.load.spritesheet('mole', '/api/asset/tileset/Nk55mERMWof92Rj9X', 146, 182)\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n  game.load.image('popup', '/api/asset/png/6rfeqF2JXEz3FwSiB')\n  // frames: 0=easy, 1=medium, 2=hard, 3=repeat\n  game.load.spritesheet('buttons', '/api/asset/tileset/7BoHNs7wDsEczqshQ', 150, 38)\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\nconst molePosition = { col: -1, row: -1 }\nlet lastAppear=0, appearDuration = 1000 // both values in miliseconds\nlet uiGroup, startPopup, endPopup\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n  \n  drawStartPopup()\n  drawEndPopup()\n}\n\n// calls 60 times a second\nfunction update(){\n  // wait till user selects level and starts the game\n  if(lastAppear === 0) return;\n  \n  // game finishes when mole appears too fast for player to react\n  if(appearDuration <= 500){\n    mole.visible = false\n    // resets game\n   lastAppear = 0 \n    return;\n  }\n  \n  const currentTimeMS = Math.round(game.time.totalElapsedSeconds() * 1000) // from ms to second\n  if(currentTimeMS - lastAppear >= appearDuration){\n    // with each appearance game gets 10ms faster\n    appearDuration -= 10\n    console.log('appearDuration', appearDuration)\n    lastAppear = currentTimeMS\n    moleAppear()\n  }\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.frame = 0\n  }\n  \n  // set mole position randomly, but don't allow appear in same spot twice\n  let newCol, newRow\n  do {\n    newCol = game.rnd.integerInRange(0, 2)\n    newRow = game.rnd.integerInRange(0, 2)\n  }\n  while (molePosition.col == newCol && molePosition.row == newRow)\n\n  molePosition.col = newCol\n  molePosition.row = newRow\n\n  let x = molePosition.col * HOLE_WIDTH\n  let y = molePosition.row * HOLE_HEIGHT + OFFSET_Y\n  mole.x = x\n  mole.y = y + 80\n  mole.alpha = 1\n\n  tween = game.add.tween(mole)\n    .to( { y: y }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( { y: y }, Math.round(appearDuration*0.2), 'Quart.easeOut')\n   .to( { y: y+80 }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( {alpha: 0}, 100, 'Quart.easeOut' )\n   .start()\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.frame = 1\n  hitCount++\n  pointsText.setText(hitCount) \n}\n\nfunction drawStartPopup(){\n  const centerX = game.world.width/2\n  const centerY = game.world.height/2\n  startPopup = game.add.group(uiGroup, 'startPopup')\n  const bg = startPopup.create(centerX, centerY, 'popup')\n  bg.anchor.set(0.5, 0.5)\n  \n  const levels = ['easy', 'medium', 'hard']\n  levels.forEach((level, i) => {\n   const button = game.add.button(centerX, centerY-90 + i*50, 'buttons', ()=>selectLevel(level), null, i, i, i)\n   button.anchor.set(0.5, 0.5)\n   startPopup.add(button)\n  })\n}\n\nfunction selectLevel (level) {\n  startPopup.visible = false\n  switch(level){\n    case 'easy':\n      appearDuration = 1000\n      break;\n    case 'medium':\n      appearDuration = 900\n      break;\n    case 'hard':\n      appearDuration = 700\n      break;\n  }\n  lastAppear = Math.round(game.time.totalElapsedSeconds() * 1000)\n}\n\nfunction drawEndPopup(){\n  \n}",
        "highlight": [
          { "from": 156, "to": 158},
          { "from": 60, "to": 60},
          { "from": 70, "to": 73}
        ]
      },
      {
        "text": "<code>drawEndPopup()</code> has all functionality needed and it is very similar to <code>drawStartPopup()</code>. Note that in update function we changed popup text by searching it second children and setting text <code>.children[1].setText()</code>.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create, update: update })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n    // mole.frame=0 - regular mole; mole.frame=1 - hit mole\n  game.load.spritesheet('mole', '/api/asset/tileset/Nk55mERMWof92Rj9X', 146, 182)\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n  game.load.image('popup', '/api/asset/png/6rfeqF2JXEz3FwSiB')\n  // frames: 0=easy, 1=medium, 2=hard, 3=repeat\n  game.load.spritesheet('buttons', '/api/asset/tileset/7BoHNs7wDsEczqshQ', 150, 38)\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\nconst molePosition = { col: -1, row: -1 }\nlet lastAppear=0, appearDuration = 1000 // both values in miliseconds\nlet uiGroup, startPopup, endPopup\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n  \n  drawStartPopup()\n  drawEndPopup()\n}\n\n// calls 60 times a second\nfunction update(){\n  // wait till user selects level and starts the game\n  if(lastAppear === 0) return;\n  \n  // game finishes when mole appears too fast for player to react\n  if(appearDuration <= 500){\n    mole.visible = false\n    // resets game\n   lastAppear = 0 \n    endPopup.visible = true\n    endPopup.children[1].setText('Game Over \n You got '+hitCount+' points')\n    return;\n  }\n  \n  const currentTimeMS = Math.round(game.time.totalElapsedSeconds() * 1000) // from ms to second\n  if(currentTimeMS - lastAppear >= appearDuration){\n    // with each appearance game gets 10ms faster\n    appearDuration -= 10\n    console.log('appearDuration', appearDuration)\n    lastAppear = currentTimeMS\n    moleAppear()\n  }\n}\n\nfunction moleAppear(){\n  if(isHit){\n    isHit = false\n    mole.frame = 0\n  }\n  \n  // set mole position randomly, but don't allow appear in same spot twice\n  let newCol, newRow\n  do {\n    newCol = game.rnd.integerInRange(0, 2)\n    newRow = game.rnd.integerInRange(0, 2)\n  }\n  while (molePosition.col == newCol && molePosition.row == newRow)\n\n  molePosition.col = newCol\n  molePosition.row = newRow\n\n  let x = molePosition.col * HOLE_WIDTH\n  let y = molePosition.row * HOLE_HEIGHT + OFFSET_Y\n  mole.x = x\n  mole.y = y + 80\n  mole.alpha = 1\n\n  tween = game.add.tween(mole)\n    .to( { y: y }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( { y: y }, Math.round(appearDuration*0.2), 'Quart.easeOut')\n   .to( { y: y+80 }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( {alpha: 0}, 100, 'Quart.easeOut' )\n   .start()\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.frame = 1\n  hitCount++\n  pointsText.setText(hitCount) \n}\n\nfunction drawStartPopup(){\n  const centerX = game.world.width/2\n  const centerY = game.world.height/2\n  startPopup = game.add.group(uiGroup, 'startPopup')\n  const bg = startPopup.create(centerX, centerY, 'popup')\n  bg.anchor.set(0.5, 0.5)\n  \n  const levels = ['easy', 'medium', 'hard']\n  levels.forEach((level, i) => {\n   const button = game.add.button(centerX, centerY-90 + i*50, 'buttons', ()=>selectLevel(level), null, i, i, i)\n   button.anchor.set(0.5, 0.5)\n   startPopup.add(button)\n  })\n}\n\nfunction selectLevel (level) {\n  startPopup.visible = false\n  switch(level){\n    case 'easy':\n      appearDuration = 1000\n      break;\n    case 'medium':\n      appearDuration = 900\n      break;\n    case 'hard':\n      appearDuration = 700\n      break;\n  }\n  lastAppear = Math.round(game.time.totalElapsedSeconds() * 1000)\n}\n\nfunction drawEndPopup(){\n  const centerX = game.world.width/2\n  const centerY = game.world.height/2\n  endPopup = game.add.group(uiGroup, 'endPopup')\n  const bg = endPopup.create(centerX, centerY, 'popup')\n  bg.anchor.set(0.5, 0.5)\n  const style = { font: '30px Arial', fill: '#ff0044', align: 'center' }\n  const text = game.add.text(centerX, centerY-50, '', style)\n  text.anchor.set(0.5, 0.5)\n  endPopup.add(text)\n  const button = game.add.button(centerX, centerY+10, 'buttons', replay, this, 3, 3, 3)\n  button.anchor.set(0.5, 0.5)\n  endPopup.add(button)\n  endPopup.visible = false\n}\n\nfunction replay(){\n  console.log('replay game') \n}",
        "highlight": [
          { "from": 73, "to": 74},
          { "from": 160, "to": 172},
          { "from": 175, "to": 177}
        ]
      },
      {
        "text": "Finally we add option to replay whole game in <code>replay()</code> function.",
        "code": "import 'phaser'\n\nvar game = new Phaser.Game(438, 600, Phaser.AUTO, 'game', { preload: preload, create: create, update: update })\n\nfunction preload() {\n  game.load.image('hole_half1', '/api/asset/png/nzjT8xBT439FZAtQS')\n  game.load.image('hole_half2', '/api/asset/png/BwfJRS7mbkSFFy3Ek')\n    // mole.frame=0 - regular mole; mole.frame=1 - hit mole\n  game.load.spritesheet('mole', '/api/asset/tileset/Nk55mERMWof92Rj9X', 146, 182)\n  game.load.audio('hitSound', '/api/asset/sound/iYaXHkHurbhD9eaRi/sound.mp3')\n  game.load.image('popup', '/api/asset/png/6rfeqF2JXEz3FwSiB')\n  // frames: 0=easy, 1=medium, 2=hard, 3=repeat\n  game.load.spritesheet('buttons', '/api/asset/tileset/7BoHNs7wDsEczqshQ', 150, 38)\n}\n\nlet mole\nlet isHit = false\nlet hitCount = 0\nlet pointsText \nconst HOLE_WIDTH = 146, HOLE_HEIGHT = 182, OFFSET_Y = 54\nconst molePosition = { col: -1, row: -1 }\nlet lastAppear=0, appearDuration = 1000 // both values in miliseconds\nlet uiGroup, startPopup, endPopup\n\nfunction create() {\n  game.stage.backgroundColor = '#1a0d09'\n  holeGroup1 = game.add.group() // hole upper parts as bottom layer\n  \n  mole = game.add.sprite(0, -999, 'mole')\n  mole.inputEnabled = true\n  mole.events.onInputDown.add(moleHit)\n  \n  holeGroup2 = game.add.group() // hole bottom parts as top layer\n  holeGroup1.y = OFFSET_Y\n  holeGroup2.y = OFFSET_Y\n\n  for (let row = 0; row < 3; row++)\n  {\n    for (let col = 0; col < 3; col++)\n    {\n      let x = col * HOLE_WIDTH\n      let y = row * HOLE_HEIGHT\n      holeGroup1.create(x, y, 'hole_half1')\n      holeGroup2.create(x, y + 70, 'hole_half2')\n    }\n  }\n\n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-10, 5, hitCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  const style2 = { font: '40px Arial', fill: '#ffffff', align: 'left' }\n  const gameTitle = game.add.text(20, 0, 'Whack a Mole', style2)\n  gameTitle.anchor.set(0, 1)\n  game.add.tween(gameTitle)\n    .to( {y: 55}, 300, 'Quart.easeOut')\n    .start()\n  \n  drawStartPopup()\n  drawEndPopup()\n}\n\n// calls 60 times a second\nfunction update(){\n  // wait till user selects level and starts the game\n  if(lastAppear === 0) return;\n  \n  // game finishes when mole appears too fast for player to react\n  if(appearDuration <= 500){\n    mole.visible = false\n    // resets game\n   lastAppear = 0 \n    endPopup.visible = true\n    endPopup.children[1].setText('Game Over \n You got '+hitCount+' points')\n    return;\n  }\n  \n  const currentTimeMS = Math.round(game.time.totalElapsedSeconds() * 1000) // from ms to second\n  if(currentTimeMS - lastAppear >= appearDuration){\n    // with each appearance game gets 10ms faster\n    appearDuration -= 10\n    console.log('appearDuration', appearDuration)\n    lastAppear = currentTimeMS\n    moleAppear()\n  }\n}\n\nfunction moleAppear(){\n  mole.visible = true\n  if(isHit){\n    isHit = false\n    mole.frame = 0\n  }\n  \n  // set mole position randomly, but don't allow appear in same spot twice\n  let newCol, newRow\n  do {\n    newCol = game.rnd.integerInRange(0, 2)\n    newRow = game.rnd.integerInRange(0, 2)\n  }\n  while (molePosition.col == newCol && molePosition.row == newRow)\n\n  molePosition.col = newCol\n  molePosition.row = newRow\n\n  let x = molePosition.col * HOLE_WIDTH\n  let y = molePosition.row * HOLE_HEIGHT + OFFSET_Y\n  mole.x = x\n  mole.y = y + 80\n  mole.alpha = 1\n\n  tween = game.add.tween(mole)\n    .to( { y: y }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( { y: y }, Math.round(appearDuration*0.2), 'Quart.easeOut')\n   .to( { y: y+80 }, Math.round(appearDuration*0.3), 'Quart.easeOut')\n   .to( {alpha: 0}, 100, 'Quart.easeOut' )\n   .start()\n}\n\nfunction moleHit(){\n  if(isHit) return;\n  isHit = true\n  mole.frame = 1\n  hitCount++\n  pointsText.setText(hitCount) \n}\n\nfunction drawStartPopup(){\n  const centerX = game.world.width/2\n  const centerY = game.world.height/2\n  startPopup = game.add.group(uiGroup, 'startPopup')\n  const bg = startPopup.create(centerX, centerY, 'popup')\n  bg.anchor.set(0.5, 0.5)\n  \n  const levels = ['easy', 'medium', 'hard']\n  levels.forEach((level, i) => {\n   const button = game.add.button(centerX, centerY-90 + i*50, 'buttons', ()=>selectLevel(level), null, i, i, i)\n   button.anchor.set(0.5, 0.5)\n   startPopup.add(button)\n  })\n}\n\nfunction selectLevel (level) {\n  startPopup.visible = false\n  switch(level){\n    case 'easy':\n      appearDuration = 1000\n      break;\n    case 'medium':\n      appearDuration = 900\n      break;\n    case 'hard':\n      appearDuration = 700\n      break;\n  }\n  lastAppear = Math.round(game.time.totalElapsedSeconds() * 1000)\n}\n\nfunction drawEndPopup(){\n  const centerX = game.world.width/2\n  const centerY = game.world.height/2\n  endPopup = game.add.group(uiGroup, 'endPopup')\n  const bg = endPopup.create(centerX, centerY, 'popup')\n  bg.anchor.set(0.5, 0.5)\n  const style = { font: '30px Arial', fill: '#ff0044', align: 'center' }\n  const text = game.add.text(centerX, centerY-50, '', style)\n  text.anchor.set(0.5, 0.5)\n  endPopup.add(text)\n  const button = game.add.button(centerX, centerY+10, 'buttons', replay, this, 3, 3, 3)\n  button.anchor.set(0.5, 0.5)\n  endPopup.add(button)\n  endPopup.visible = false\n}\n\nfunction replay(){\n  endPopup.visible = false\n  startPopup.visible = true\n  hitCount = 0\n  pointsText.setText(hitCount)\n}",
        "highlight": [
          { "from": 177, "to": 180}
        ]
      }
    ]
  },



  "digger": {
    "steps": [
      {
        "text": "In this tutorial we will create a simple mini-game called Digger. The game is about a little miner who searches gold by digging dirt blocks. Arrow keys will be used for navigation and a simple physics and collision will be added to miner object.<br/><br/>Let’s start with a basic game template: Phaser import, game object and default functions: preload, create, update, render. Game logic will happen in blocks, so we are setting global variables for defining size.",
        "code": "import 'phaser'\n\nconst BLOCK_WIDTH=64, BLOCK_HEIGHT=64\n\nconst game = new Phaser.Game(\n  BLOCK_WIDTH*8, \n  BLOCK_HEIGHT*8, \n  Phaser.AUTO, \n  'game', \n  { preload: preload, create: create, update: update, render: render }\n)\n\nfunction preload(){\n\n}\n\nfunction create(){\n\n}\n\nfunction update(){\n\n}\n\nfunction render(){\n\n}\n"
      },
      {
        "text": "<b>Preload assets</b>. In <code>preload</code> function all graphic assets are defined.",
        "code": "import 'phaser'\n\nconst BLOCK_WIDTH=64, BLOCK_HEIGHT=64\n\nconst game = new Phaser.Game(\n  BLOCK_WIDTH*8, \n  BLOCK_HEIGHT*8, \n  Phaser.AUTO, \n  'game', \n  { preload: preload, create: create, update: update, render: render }\n)\n\nfunction preload(){\n  game.load.image('bg', '/api/asset/png/gPDHnefr3cmYtMvur')\n  game.load.image('gold', '/api/asset/png/HrnoQfeqZ8G4Ejy9u')\n  game.load.image('grass', '/api/asset/png/CfdzA4kAGp3JCeqHX')\n  game.load.image('ground', '/api/asset/png/dKYcXBz82W6npYDer')\n  game.load.image('rock', '/api/asset/png/in9dqmm4wCsFd865y')\n  game.load.image('shop', '/api/asset/png/CoW7dywTwBYKvkSfQ')\n  game.load.spritesheet('player', '/api/asset/tileset/FQvBgz8R5AepmBdnE', 90, 90)\n}\n\nfunction create(){\n\n}\n\nfunction update(){\n\n}\n\nfunction render(){\n\n}\n", 
        "highlight": [
          { "from": 14, "to": 20 }
        ]
      },
      {
        "text": "<b>Drawing sprites</b>. Create a background, shop and blocks. For blocks we will create a Phaser group and put there random block types. After inserting code run the game to check if graphics are displayed.",
        "code": "import 'phaser'\n\nconst BLOCK_WIDTH=64, BLOCK_HEIGHT=64\nconst OFFSET_Y=3*64\nlet blocks\nconst blockTypes = ['grass', 'ground', 'gold', 'rock']\n\nconst game = new Phaser.Game(\n  BLOCK_WIDTH*8, \n  BLOCK_HEIGHT*8, \n  Phaser.AUTO, \n  'game', \n  { preload: preload, create: create, update: update, render: render }\n)\n\nfunction preload(){\n  game.load.image('bg', '/api/asset/png/gPDHnefr3cmYtMvur')\n  game.load.image('gold', '/api/asset/png/HrnoQfeqZ8G4Ejy9u')\n  game.load.image('grass', '/api/asset/png/CfdzA4kAGp3JCeqHX')\n  game.load.image('ground', '/api/asset/png/dKYcXBz82W6npYDer')\n  game.load.image('rock', '/api/asset/png/in9dqmm4wCsFd865y')\n  game.load.image('shop', '/api/asset/png/CoW7dywTwBYKvkSfQ')\n  game.load.spritesheet('player', '/api/asset/tileset/FQvBgz8R5AepmBdnE', 90, 90)\n}\n\nfunction create(){\n  game.add.sprite(0, 0, 'bg')\n  shop = game.add.sprite(200, -5, 'shop')\n  blocks = game.add.group()\n  blocks.y = OFFSET_Y\n  for(let row=0; row<6; row++){\n    for(let col=0; col<8; col++){\n      let x = col * BLOCK_WIDTH\n      let y = row * BLOCK_HEIGHT\n      let type = game.rnd.integerInRange(0, blockTypes.length-1)\n      blocks.create(x, y, blockTypes[type])\n    }\n  }\n}\n\nfunction update(){\n\n}\n\nfunction render(){\n\n}\n", 
        "highlight": [
          { "from": 4, "to": 6 },
          { "from": 27, "to": 38 }
        ]
      },
      {
        "text": "<b>Player</b>.We definitely need a player. Create a sprite as usual and add animations with <code>player.animation.add()</code> method by passing animation name, related frames, fps and boolean if looping is enabled. This is convenient method to call animation later in the game with one line of code.",
        "code": "import 'phaser'\n\nconst BLOCK_WIDTH=64, BLOCK_HEIGHT=64\nconst OFFSET_Y=3*64\nlet blocks\nconst blockTypes = ['grass', 'ground', 'gold', 'rock']\nlet player\nlet digAnimation\n\nconst game = new Phaser.Game(\n  BLOCK_WIDTH*8, \n  BLOCK_HEIGHT*8, \n  Phaser.AUTO, \n  'game', \n  { preload: preload, create: create, update: update, render: render }\n)\n\nfunction preload(){\n  game.load.image('bg', '/api/asset/png/gPDHnefr3cmYtMvur')\n  game.load.image('gold', '/api/asset/png/HrnoQfeqZ8G4Ejy9u')\n  game.load.image('grass', '/api/asset/png/CfdzA4kAGp3JCeqHX')\n  game.load.image('ground', '/api/asset/png/dKYcXBz82W6npYDer')\n  game.load.image('rock', '/api/asset/png/in9dqmm4wCsFd865y')\n  game.load.image('shop', '/api/asset/png/CoW7dywTwBYKvkSfQ')\n  game.load.spritesheet('player', '/api/asset/tileset/FQvBgz8R5AepmBdnE', 90, 90)\n}\n\nfunction create(){\n  game.add.sprite(0, 0, 'bg')\n  shop = game.add.sprite(200, -5, 'shop')\n  blocks = game.add.group()\n  blocks.y = OFFSET_Y\n  for(let row=0; row<6; row++){\n    for(let col=0; col<8; col++){\n      let x = col * BLOCK_WIDTH\n      let y = row * BLOCK_HEIGHT\n      let type = game.rnd.integerInRange(0, blockTypes.length-1)\n      blocks.create(x, y, blockTypes[type])\n    }\n  }\n  \n  player = game.add.sprite(50, 50, 'player')\n  player.anchor.set(0.5, 0.5)\n  player.animations.add('stand', [0, 1, 2, 3], 10, true)\n  player.animations.add('fly', [4, 5, 6, 7], 10, true)\n  player.animations.add('run', [8, 9, 10], 10, true)\n  player.animations.add('fall', [11, 12, 13, 14], 10, true)\n  player.animations.add('dig', [15, 16, 17], 10, false)\n  player.animations.add('dig_down', [18, 19, 20], 10, false)\n  player.animations.play('stand')\n}\n\nfunction update(){\n\n}\n\nfunction render(){\n\n}\n", 
        "highlight": [
          { "from": 7, "to": 8 },
          { "from": 42, "to": 50 }
        ]
      },
      {
        "text": "<b>Physics</b>. We need a way for player to move around and interact with object. One way is to calculate sprite positions ourselves, but we’ll choose a simpler method - adding physics to game. At first we’ll define which objects do need physics and pass them in array to <code>game.physics.arcade.enable()</code> method. Note that passing group will apply physics to its children. After that we are setting gravity, immovable and other variables in code below.",
        "code": "import 'phaser'\n\nconst BLOCK_WIDTH=64, BLOCK_HEIGHT=64\nconst OFFSET_Y=3*64\nlet blocks\nconst blockTypes = ['grass', 'ground', 'gold', 'rock']\nlet player\nlet digAnimation\n\nconst game = new Phaser.Game(\n  BLOCK_WIDTH*8, \n  BLOCK_HEIGHT*8, \n  Phaser.AUTO, \n  'game', \n  { preload: preload, create: create, update: update, render: render }\n)\n\nfunction preload(){\n  game.load.image('bg', '/api/asset/png/gPDHnefr3cmYtMvur')\n  game.load.image('gold', '/api/asset/png/HrnoQfeqZ8G4Ejy9u')\n  game.load.image('grass', '/api/asset/png/CfdzA4kAGp3JCeqHX')\n  game.load.image('ground', '/api/asset/png/dKYcXBz82W6npYDer')\n  game.load.image('rock', '/api/asset/png/in9dqmm4wCsFd865y')\n  game.load.image('shop', '/api/asset/png/CoW7dywTwBYKvkSfQ')\n  game.load.spritesheet('player', '/api/asset/tileset/FQvBgz8R5AepmBdnE', 90, 90)\n}\n\nfunction create(){\n  game.add.sprite(0, 0, 'bg')\n  shop = game.add.sprite(200, -5, 'shop')\n  blocks = game.add.group()\n  blocks.y = OFFSET_Y\n  for(let row=0; row<6; row++){\n    for(let col=0; col<8; col++){\n      let x = col * BLOCK_WIDTH\n      let y = row * BLOCK_HEIGHT\n      let type = game.rnd.integerInRange(0, blockTypes.length-1)\n      blocks.create(x, y, blockTypes[type])\n    }\n  }\n  \n  player = game.add.sprite(50, 50, 'player')\n  player.anchor.set(0.5, 0.5)\n  player.animations.add('stand', [0, 1, 2, 3], 10, true)\n  player.animations.add('fly', [4, 5, 6, 7], 10, true)\n  player.animations.add('run', [8, 9, 10], 10, true)\n  player.animations.add('fall', [11, 12, 13, 14], 10, true)\n  player.animations.add('dig', [15, 16, 17], 10, false)\n  player.animations.add('dig_down', [18, 19, 20], 10, false)\n  player.animations.play('stand')\n  \n  game.physics.arcade.enable([player, shop, blocks])\n  player.body.collideWorldBounds = true\n  player.body.gravity.y = 1000\n  player.body.width = 50\n  player.body.height = 60\n  blocks.setAll('body.immovable', true)\n}\n\nfunction update(){\n\n}\n\nfunction render(){\n\n}\n", 
        "highlight": [
          { "from": 52, "to": 57 }
        ]
      },
      {
        "text": "<b>UI counter</b>. Lets add a simple point counter with game.add.text method.",
        "code": "import 'phaser'\n\nconst BLOCK_WIDTH=64, BLOCK_HEIGHT=64\nconst OFFSET_Y=3*64\nlet blocks\nconst blockTypes = ['grass', 'ground', 'gold', 'rock']\nlet player\nlet digAnimation\nlet pointsText\nlet goldCount=0, pointCount=0\n\nconst game = new Phaser.Game(\n  BLOCK_WIDTH*8, \n  BLOCK_HEIGHT*8, \n  Phaser.AUTO, \n  'game', \n  { preload: preload, create: create, update: update, render: render }\n)\n\nfunction preload(){\n  game.load.image('bg', '/api/asset/png/gPDHnefr3cmYtMvur')\n  game.load.image('gold', '/api/asset/png/HrnoQfeqZ8G4Ejy9u')\n  game.load.image('grass', '/api/asset/png/CfdzA4kAGp3JCeqHX')\n  game.load.image('ground', '/api/asset/png/dKYcXBz82W6npYDer')\n  game.load.image('rock', '/api/asset/png/in9dqmm4wCsFd865y')\n  game.load.image('shop', '/api/asset/png/CoW7dywTwBYKvkSfQ')\n  game.load.spritesheet('player', '/api/asset/tileset/FQvBgz8R5AepmBdnE', 90, 90)\n}\n\nfunction create(){\n  game.add.sprite(0, 0, 'bg')\n  shop = game.add.sprite(200, -5, 'shop')\n  blocks = game.add.group()\n  blocks.y = OFFSET_Y\n  for(let row=0; row<6; row++){\n    for(let col=0; col<8; col++){\n      let x = col * BLOCK_WIDTH\n      let y = row * BLOCK_HEIGHT\n      let type = game.rnd.integerInRange(0, blockTypes.length-1)\n      blocks.create(x, y, blockTypes[type])\n    }\n  }\n  \n  player = game.add.sprite(50, 50, 'player')\n  player.anchor.set(0.5, 0.5)\n  player.animations.add('stand', [0, 1, 2, 3], 10, true)\n  player.animations.add('fly', [4, 5, 6, 7], 10, true)\n  player.animations.add('run', [8, 9, 10], 10, true)\n  player.animations.add('fall', [11, 12, 13, 14], 10, true)\n  player.animations.add('dig', [15, 16, 17], 10, false)\n  player.animations.add('dig_down', [18, 19, 20], 10, false)\n  player.animations.play('stand')\n  \n  game.physics.arcade.enable([player, shop, blocks])\n  player.body.collideWorldBounds = true\n  player.body.gravity.y = 1000\n  player.body.width = 50\n  player.body.height = 60\n  blocks.setAll('body.immovable', true)\n  \n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-50, 5, pointCount, style)\n  pointsText.anchor.set(1, 0)\n}\n\nfunction update(){\n\n}\n\nfunction render(){\n\n}\n", 
        "highlight": [
          { "from": 9, "to": 10 },
          { "from": 61, "to": 63 }
        ]
      },
      {
        "text": "<b>User input</b>. Track user input. Both arrow keys and touch. Because we use both of inputs we need <code>direction</code> variable to store which direction character needs to go. Function <code>onUp</code> clears all directions.",
        "code": "import 'phaser'\n\nconst BLOCK_WIDTH=64, BLOCK_HEIGHT=64\nconst OFFSET_Y=3*64\nlet blocks\nconst blockTypes = ['grass', 'ground', 'gold', 'rock']\nlet player\nlet digAnimation\nlet pointsText\nlet goldCount=0, pointCount=0\nlet cursors\nlet direction = { UP: false, DOWN: false, LEFT: false, RIGHT: false }\n\nconst game = new Phaser.Game(\n  BLOCK_WIDTH*8, \n  BLOCK_HEIGHT*8, \n  Phaser.AUTO, \n  'game', \n  { preload: preload, create: create, update: update, render: render }\n)\n\nfunction preload(){\n  game.load.image('bg', '/api/asset/png/gPDHnefr3cmYtMvur')\n  game.load.image('gold', '/api/asset/png/HrnoQfeqZ8G4Ejy9u')\n  game.load.image('grass', '/api/asset/png/CfdzA4kAGp3JCeqHX')\n  game.load.image('ground', '/api/asset/png/dKYcXBz82W6npYDer')\n  game.load.image('rock', '/api/asset/png/in9dqmm4wCsFd865y')\n  game.load.image('shop', '/api/asset/png/CoW7dywTwBYKvkSfQ')\n  game.load.spritesheet('player', '/api/asset/tileset/FQvBgz8R5AepmBdnE', 90, 90)\n}\n\nfunction create(){\n  game.add.sprite(0, 0, 'bg')\n  shop = game.add.sprite(200, -5, 'shop')\n  blocks = game.add.group()\n  blocks.y = OFFSET_Y\n  for(let row=0; row<6; row++){\n    for(let col=0; col<8; col++){\n      let x = col * BLOCK_WIDTH\n      let y = row * BLOCK_HEIGHT\n      let type = game.rnd.integerInRange(0, blockTypes.length-1)\n      blocks.create(x, y, blockTypes[type])\n    }\n  }\n  \n  player = game.add.sprite(50, 50, 'player')\n  player.anchor.set(0.5, 0.5)\n  player.animations.add('stand', [0, 1, 2, 3], 10, true)\n  player.animations.add('fly', [4, 5, 6, 7], 10, true)\n  player.animations.add('run', [8, 9, 10], 10, true)\n  player.animations.add('fall', [11, 12, 13, 14], 10, true)\n  player.animations.add('dig', [15, 16, 17], 10, false)\n  player.animations.add('dig_down', [18, 19, 20], 10, false)\n  player.animations.play('stand')\n  \n  game.physics.arcade.enable([player, shop, blocks])\n  player.body.collideWorldBounds = true\n  player.body.gravity.y = 1000\n  player.body.width = 50\n  player.body.height = 60\n  blocks.setAll('body.immovable', true)\n  \n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-50, 5, pointCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  cursors = game.input.keyboard.createCursorKeys()\n  cursors.up.onDown.add(() => direction.UP=true)\n  cursors.up.onUp.add(onUp)\n  cursors.down.onDown.add(() => direction.DOWN=true)\n  cursors.down.onUp.add(onUp)\n  cursors.left.onDown.add(() => direction.LEFT=true)\n  cursors.left.onUp.add(onUp)\n  cursors.right.onDown.add(() => direction.RIGHT=true)\n  cursors.right.onUp.add(onUp)\n  // user input mouse/touch\n  game.input.onDown.add(onDown)\n  game.input.onUp.add(onUp)\n}\n\nfunction update(){\n\n}\n\nfunction render(){\n\n}\n\nfunction onUp(){\n  direction = { UP: false, DOWN: false, LEFT: false, RIGHT: false }\n}\n\nfunction onDown(){\n  onUp()\n  let dir\n  const isVertical = Math.abs(game.input.x - player.x) < Math.abs(game.input.y - player.y)\n  if(isVertical) dir = game.input.y > player.y ? 'DOWN' : 'UP'\n  else dir = game.input.x > player.x ? 'RIGHT' : 'LEFT'\n  direction[dir] = true\n}\n", 
        "highlight": [
          { "from": 11, "to": 12 },
          { "from": 67, "to": 78 },
          { "from": 89, "to": 100 }
        ]
      },
      {
        "text": "<b>Collision detection</b>. We need to get event when character is touching a block. There is a <code>collide</code> method in game physics object. By passing player object and block group object we get a callback whenever they touch. After that we check if player direction is opposite to block direction. For example if player moves to right and is touching block from left then dig that block.",
        "code": "import 'phaser'\n\nconst BLOCK_WIDTH=64, BLOCK_HEIGHT=64\nconst OFFSET_Y=3*64\nlet blocks\nconst blockTypes = ['grass', 'ground', 'gold', 'rock']\nlet player\nlet digAnimation\nlet pointsText\nlet goldCount=0, pointCount=0\nlet cursors\nlet direction = { UP: false, DOWN: false, LEFT: false, RIGHT: false }\n\nconst game = new Phaser.Game(\n  BLOCK_WIDTH*8, \n  BLOCK_HEIGHT*8, \n  Phaser.AUTO, \n  'game', \n  { preload: preload, create: create, update: update, render: render }\n)\n\nfunction preload(){\n  game.load.image('bg', '/api/asset/png/gPDHnefr3cmYtMvur')\n  game.load.image('gold', '/api/asset/png/HrnoQfeqZ8G4Ejy9u')\n  game.load.image('grass', '/api/asset/png/CfdzA4kAGp3JCeqHX')\n  game.load.image('ground', '/api/asset/png/dKYcXBz82W6npYDer')\n  game.load.image('rock', '/api/asset/png/in9dqmm4wCsFd865y')\n  game.load.image('shop', '/api/asset/png/CoW7dywTwBYKvkSfQ')\n  game.load.spritesheet('player', '/api/asset/tileset/FQvBgz8R5AepmBdnE', 90, 90)\n}\n\nfunction create(){\n  game.add.sprite(0, 0, 'bg')\n  shop = game.add.sprite(200, -5, 'shop')\n  blocks = game.add.group()\n  blocks.y = OFFSET_Y\n  for(let row=0; row<6; row++){\n    for(let col=0; col<8; col++){\n      let x = col * BLOCK_WIDTH\n      let y = row * BLOCK_HEIGHT\n      let type = game.rnd.integerInRange(0, blockTypes.length-1)\n      blocks.create(x, y, blockTypes[type])\n    }\n  }\n  \n  player = game.add.sprite(50, 50, 'player')\n  player.anchor.set(0.5, 0.5)\n  player.animations.add('stand', [0, 1, 2, 3], 10, true)\n  player.animations.add('fly', [4, 5, 6, 7], 10, true)\n  player.animations.add('run', [8, 9, 10], 10, true)\n  player.animations.add('fall', [11, 12, 13, 14], 10, true)\n  player.animations.add('dig', [15, 16, 17], 10, false)\n  player.animations.add('dig_down', [18, 19, 20], 10, false)\n  player.animations.play('stand')\n  \n  game.physics.arcade.enable([player, shop, blocks])\n  player.body.collideWorldBounds = true\n  player.body.gravity.y = 1000\n  player.body.width = 50\n  player.body.height = 60\n  blocks.setAll('body.immovable', true)\n  \n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-50, 5, pointCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  cursors = game.input.keyboard.createCursorKeys()\n  cursors.up.onDown.add(() => direction.UP=true)\n  cursors.up.onUp.add(onUp)\n  cursors.down.onDown.add(() => direction.DOWN=true)\n  cursors.down.onUp.add(onUp)\n  cursors.left.onDown.add(() => direction.LEFT=true)\n  cursors.left.onUp.add(onUp)\n  cursors.right.onDown.add(() => direction.RIGHT=true)\n  cursors.right.onUp.add(onUp)\n  // user input mouse/touch\n  game.input.onDown.add(onDown)\n  game.input.onUp.add(onUp)\n}\n\nfunction update(){\n  let collideDown = false\n  game.physics.arcade.collide(player, blocks, function(character, block){\n    if(digAnimation) return null\n\n    if(direction.LEFT){\n      if(block.body.touching.right){\n        digAnimation = player.animations.play('dig')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('run')\n      }\n    }\n    else if(direction.RIGHT){\n      if(block.body.touching.left){\n        digAnimation = player.animations.play('dig')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('run')\n      }\n    }\n    else if(direction.DOWN){\n      if(block.body.touching.up){\n        digAnimation = player.animations.play('dig_down')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('stand')\n      }\n    }\n\n    if(block.body.touching.up){\n      collideDown = true\n    }\n  }, null)\n}\n\nfunction render(){\n\n}\n\nfunction onUp(){\n  direction = { UP: false, DOWN: false, LEFT: false, RIGHT: false }\n}\n\nfunction onDown(){\n  onUp()\n  let dir\n  const isVertical = Math.abs(game.input.x - player.x) < Math.abs(game.input.y - player.y)\n  if(isVertical) dir = game.input.y > player.y ? 'DOWN' : 'UP'\n  else dir = game.input.x > player.x ? 'RIGHT' : 'LEFT'\n  direction[dir] = true\n}\n\nfunction destroyBlock(block){\n  block.destroy()\n}", 
        "highlight": [
          { "from": 82, "to": 114 },
          { "from": 134, "to": 136 }
        ]
      },
      {
        "text": "<b>Sprite direction</b>. After that we add more code to <code>update()</code> function. Our goal is to set player sprite in correct direction. Originally all animations are to left side and if the player runs opposite direction we simply flip a sprite <code>player.scale.x = -1</code>",
        "code": "import 'phaser'\n\nconst BLOCK_WIDTH=64, BLOCK_HEIGHT=64\nconst OFFSET_Y=3*64\nlet blocks\nconst blockTypes = ['grass', 'ground', 'gold', 'rock']\nlet player\nlet digAnimation\nlet pointsText\nlet goldCount=0, pointCount=0\nlet cursors\nlet direction = { UP: false, DOWN: false, LEFT: false, RIGHT: false }\n\nconst game = new Phaser.Game(\n  BLOCK_WIDTH*8, \n  BLOCK_HEIGHT*8, \n  Phaser.AUTO, \n  'game', \n  { preload: preload, create: create, update: update, render: render }\n)\n\nfunction preload(){\n  game.load.image('bg', '/api/asset/png/gPDHnefr3cmYtMvur')\n  game.load.image('gold', '/api/asset/png/HrnoQfeqZ8G4Ejy9u')\n  game.load.image('grass', '/api/asset/png/CfdzA4kAGp3JCeqHX')\n  game.load.image('ground', '/api/asset/png/dKYcXBz82W6npYDer')\n  game.load.image('rock', '/api/asset/png/in9dqmm4wCsFd865y')\n  game.load.image('shop', '/api/asset/png/CoW7dywTwBYKvkSfQ')\n  game.load.spritesheet('player', '/api/asset/tileset/FQvBgz8R5AepmBdnE', 90, 90)\n}\n\nfunction create(){\n  game.add.sprite(0, 0, 'bg')\n  shop = game.add.sprite(200, -5, 'shop')\n  blocks = game.add.group()\n  blocks.y = OFFSET_Y\n  for(let row=0; row<6; row++){\n    for(let col=0; col<8; col++){\n      let x = col * BLOCK_WIDTH\n      let y = row * BLOCK_HEIGHT\n      let type = game.rnd.integerInRange(0, blockTypes.length-1)\n      blocks.create(x, y, blockTypes[type])\n    }\n  }\n  \n  player = game.add.sprite(50, 50, 'player')\n  player.anchor.set(0.5, 0.5)\n  player.animations.add('stand', [0, 1, 2, 3], 10, true)\n  player.animations.add('fly', [4, 5, 6, 7], 10, true)\n  player.animations.add('run', [8, 9, 10], 10, true)\n  player.animations.add('fall', [11, 12, 13, 14], 10, true)\n  player.animations.add('dig', [15, 16, 17], 10, false)\n  player.animations.add('dig_down', [18, 19, 20], 10, false)\n  player.animations.play('stand')\n  \n  game.physics.arcade.enable([player, shop, blocks])\n  player.body.collideWorldBounds = true\n  player.body.gravity.y = 1000\n  player.body.width = 50\n  player.body.height = 60\n  blocks.setAll('body.immovable', true)\n  \n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-50, 5, pointCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  cursors = game.input.keyboard.createCursorKeys()\n  cursors.up.onDown.add(() => direction.UP=true)\n  cursors.up.onUp.add(onUp)\n  cursors.down.onDown.add(() => direction.DOWN=true)\n  cursors.down.onUp.add(onUp)\n  cursors.left.onDown.add(() => direction.LEFT=true)\n  cursors.left.onUp.add(onUp)\n  cursors.right.onDown.add(() => direction.RIGHT=true)\n  cursors.right.onUp.add(onUp)\n  // user input mouse/touch\n  game.input.onDown.add(onDown)\n  game.input.onUp.add(onUp)\n}\n\nfunction update(){\n  let collideDown = false\n  game.physics.arcade.collide(player, blocks, function(character, block){\n    if(digAnimation) return null\n\n    if(direction.LEFT){\n      if(block.body.touching.right){\n        digAnimation = player.animations.play('dig')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('run')\n      }\n    }\n    else if(direction.RIGHT){\n      if(block.body.touching.left){\n        digAnimation = player.animations.play('dig')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('run')\n      }\n    }\n    else if(direction.DOWN){\n      if(block.body.touching.up){\n        digAnimation = player.animations.play('dig_down')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('stand')\n      }\n    }\n\n    if(block.body.touching.up){\n      collideDown = true\n    }\n  }, null)\n  \n  if(digAnimation) return null\n\n  if(direction.LEFT){\n    player.scale.x = -1\n    player.body.velocity.x = -200\n  }\n  else if(direction.RIGHT){\n    player.scale.x = 1\n    player.body.velocity.x = 200\n  }\n  else {\n    player.body.velocity.x = 0\n  }\n}\n\nfunction render(){\n\n}\n\nfunction onUp(){\n  direction = { UP: false, DOWN: false, LEFT: false, RIGHT: false }\n}\n\nfunction onDown(){\n  onUp()\n  let dir\n  const isVertical = Math.abs(game.input.x - player.x) < Math.abs(game.input.y - player.y)\n  if(isVertical) dir = game.input.y > player.y ? 'DOWN' : 'UP'\n  else dir = game.input.x > player.x ? 'RIGHT' : 'LEFT'\n  direction[dir] = true\n}\n\nfunction destroyBlock(block){\n  block.destroy()\n}", 
        "highlight": [
          { "from": 116, "to": 128 }
        ]
      },
      {
        "text": "<b>Player up/down</b>. We are not checking up direction yet. So add code to <code>update()</update> function and set y velocity if direction is correct and also set proper animations from character.",
        "code": "import 'phaser'\n\nconst BLOCK_WIDTH=64, BLOCK_HEIGHT=64\nconst OFFSET_Y=3*64\nlet blocks\nconst blockTypes = ['grass', 'ground', 'gold', 'rock']\nlet player\nlet digAnimation\nlet pointsText\nlet goldCount=0, pointCount=0\nlet cursors\nlet direction = { UP: false, DOWN: false, LEFT: false, RIGHT: false }\n\nconst game = new Phaser.Game(\n  BLOCK_WIDTH*8, \n  BLOCK_HEIGHT*8, \n  Phaser.AUTO, \n  'game', \n  { preload: preload, create: create, update: update, render: render }\n)\n\nfunction preload(){\n  game.load.image('bg', '/api/asset/png/gPDHnefr3cmYtMvur')\n  game.load.image('gold', '/api/asset/png/HrnoQfeqZ8G4Ejy9u')\n  game.load.image('grass', '/api/asset/png/CfdzA4kAGp3JCeqHX')\n  game.load.image('ground', '/api/asset/png/dKYcXBz82W6npYDer')\n  game.load.image('rock', '/api/asset/png/in9dqmm4wCsFd865y')\n  game.load.image('shop', '/api/asset/png/CoW7dywTwBYKvkSfQ')\n  game.load.spritesheet('player', '/api/asset/tileset/FQvBgz8R5AepmBdnE', 90, 90)\n}\n\nfunction create(){\n  game.add.sprite(0, 0, 'bg')\n  shop = game.add.sprite(200, -5, 'shop')\n  blocks = game.add.group()\n  blocks.y = OFFSET_Y\n  for(let row=0; row<6; row++){\n    for(let col=0; col<8; col++){\n      let x = col * BLOCK_WIDTH\n      let y = row * BLOCK_HEIGHT\n      let type = game.rnd.integerInRange(0, blockTypes.length-1)\n      blocks.create(x, y, blockTypes[type])\n    }\n  }\n  \n  player = game.add.sprite(50, 50, 'player')\n  player.anchor.set(0.5, 0.5)\n  player.animations.add('stand', [0, 1, 2, 3], 10, true)\n  player.animations.add('fly', [4, 5, 6, 7], 10, true)\n  player.animations.add('run', [8, 9, 10], 10, true)\n  player.animations.add('fall', [11, 12, 13, 14], 10, true)\n  player.animations.add('dig', [15, 16, 17], 10, false)\n  player.animations.add('dig_down', [18, 19, 20], 10, false)\n  player.animations.play('stand')\n  \n  game.physics.arcade.enable([player, shop, blocks])\n  player.body.collideWorldBounds = true\n  player.body.gravity.y = 1000\n  player.body.width = 50\n  player.body.height = 60\n  blocks.setAll('body.immovable', true)\n  \n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-50, 5, pointCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  cursors = game.input.keyboard.createCursorKeys()\n  cursors.up.onDown.add(() => direction.UP=true)\n  cursors.up.onUp.add(onUp)\n  cursors.down.onDown.add(() => direction.DOWN=true)\n  cursors.down.onUp.add(onUp)\n  cursors.left.onDown.add(() => direction.LEFT=true)\n  cursors.left.onUp.add(onUp)\n  cursors.right.onDown.add(() => direction.RIGHT=true)\n  cursors.right.onUp.add(onUp)\n  // user input mouse/touch\n  game.input.onDown.add(onDown)\n  game.input.onUp.add(onUp)\n}\n\nfunction update(){\n  let collideDown = false\n  game.physics.arcade.collide(player, blocks, function(character, block){\n    if(digAnimation) return null\n\n    if(direction.LEFT){\n      if(block.body.touching.right){\n        digAnimation = player.animations.play('dig')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('run')\n      }\n    }\n    else if(direction.RIGHT){\n      if(block.body.touching.left){\n        digAnimation = player.animations.play('dig')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('run')\n      }\n    }\n    else if(direction.DOWN){\n      if(block.body.touching.up){\n        digAnimation = player.animations.play('dig_down')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('stand')\n      }\n    }\n\n    if(block.body.touching.up){\n      collideDown = true\n    }\n  }, null)\n  \n  if(digAnimation) return null\n\n  if(direction.LEFT){\n    player.scale.x = -1\n    player.body.velocity.x = -200\n  }\n  else if(direction.RIGHT){\n    player.scale.x = 1\n    player.body.velocity.x = 200\n  }\n  else {\n    player.body.velocity.x = 0\n  }\n  \n  if(direction.UP){\n    player.body.velocity.y = -300\n    player.animations.play('fly')\n  } else {\n    if(!collideDown){\n      player.animations.play('fall')\n    }\n    else if(player.body.velocity.x === 0){\n      player.animations.play('stand')\n    }\n  }\n}\n\nfunction render(){\n\n}\n\nfunction onUp(){\n  direction = { UP: false, DOWN: false, LEFT: false, RIGHT: false }\n}\n\nfunction onDown(){\n  onUp()\n  let dir\n  const isVertical = Math.abs(game.input.x - player.x) < Math.abs(game.input.y - player.y)\n  if(isVertical) dir = game.input.y > player.y ? 'DOWN' : 'UP'\n  else dir = game.input.x > player.x ? 'RIGHT' : 'LEFT'\n  direction[dir] = true\n}\n\nfunction destroyBlock(block){\n  block.destroy()\n}", 
        "highlight": [
          { "from": 130, "to": 140 }
        ]
      },
      {
        "text": "<b>Destroy block</b>. Currently player destroys all blocks and we need to change it. By sprite <code>key</code> value we check block type. If it’s grass or ground we destroy it, if gold then increase <code>goldCount</code> parameter and if rock then do nothing.",
        "code": "import 'phaser'\n\nconst BLOCK_WIDTH=64, BLOCK_HEIGHT=64\nconst OFFSET_Y=3*64\nlet blocks\nconst blockTypes = ['grass', 'ground', 'gold', 'rock']\nlet player\nlet digAnimation\nlet pointsText\nlet goldCount=0, pointCount=0\nlet cursors\nlet direction = { UP: false, DOWN: false, LEFT: false, RIGHT: false }\n\nconst game = new Phaser.Game(\n  BLOCK_WIDTH*8, \n  BLOCK_HEIGHT*8, \n  Phaser.AUTO, \n  'game', \n  { preload: preload, create: create, update: update, render: render }\n)\n\nfunction preload(){\n  game.load.image('bg', '/api/asset/png/gPDHnefr3cmYtMvur')\n  game.load.image('gold', '/api/asset/png/HrnoQfeqZ8G4Ejy9u')\n  game.load.image('grass', '/api/asset/png/CfdzA4kAGp3JCeqHX')\n  game.load.image('ground', '/api/asset/png/dKYcXBz82W6npYDer')\n  game.load.image('rock', '/api/asset/png/in9dqmm4wCsFd865y')\n  game.load.image('shop', '/api/asset/png/CoW7dywTwBYKvkSfQ')\n  game.load.spritesheet('player', '/api/asset/tileset/FQvBgz8R5AepmBdnE', 90, 90)\n}\n\nfunction create(){\n  game.add.sprite(0, 0, 'bg')\n  shop = game.add.sprite(200, -5, 'shop')\n  blocks = game.add.group()\n  blocks.y = OFFSET_Y\n  for(let row=0; row<6; row++){\n    for(let col=0; col<8; col++){\n      let x = col * BLOCK_WIDTH\n      let y = row * BLOCK_HEIGHT\n      let type = game.rnd.integerInRange(0, blockTypes.length-1)\n      blocks.create(x, y, blockTypes[type])\n    }\n  }\n  \n  player = game.add.sprite(50, 50, 'player')\n  player.anchor.set(0.5, 0.5)\n  player.animations.add('stand', [0, 1, 2, 3], 10, true)\n  player.animations.add('fly', [4, 5, 6, 7], 10, true)\n  player.animations.add('run', [8, 9, 10], 10, true)\n  player.animations.add('fall', [11, 12, 13, 14], 10, true)\n  player.animations.add('dig', [15, 16, 17], 10, false)\n  player.animations.add('dig_down', [18, 19, 20], 10, false)\n  player.animations.play('stand')\n  \n  game.physics.arcade.enable([player, shop, blocks])\n  player.body.collideWorldBounds = true\n  player.body.gravity.y = 1000\n  player.body.width = 50\n  player.body.height = 60\n  blocks.setAll('body.immovable', true)\n  \n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-50, 5, pointCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  cursors = game.input.keyboard.createCursorKeys()\n  cursors.up.onDown.add(() => direction.UP=true)\n  cursors.up.onUp.add(onUp)\n  cursors.down.onDown.add(() => direction.DOWN=true)\n  cursors.down.onUp.add(onUp)\n  cursors.left.onDown.add(() => direction.LEFT=true)\n  cursors.left.onUp.add(onUp)\n  cursors.right.onDown.add(() => direction.RIGHT=true)\n  cursors.right.onUp.add(onUp)\n  // user input mouse/touch\n  game.input.onDown.add(onDown)\n  game.input.onUp.add(onUp)\n}\n\nfunction update(){\n  let collideDown = false\n  game.physics.arcade.collide(player, blocks, function(character, block){\n    if(digAnimation) return null\n\n    if(direction.LEFT){\n      if(block.body.touching.right){\n        digAnimation = player.animations.play('dig')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('run')\n      }\n    }\n    else if(direction.RIGHT){\n      if(block.body.touching.left){\n        digAnimation = player.animations.play('dig')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('run')\n      }\n    }\n    else if(direction.DOWN){\n      if(block.body.touching.up){\n        digAnimation = player.animations.play('dig_down')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('stand')\n      }\n    }\n\n    if(block.body.touching.up){\n      collideDown = true\n    }\n  }, null)\n  \n  if(digAnimation) return null\n\n  if(direction.LEFT){\n    player.scale.x = -1\n    player.body.velocity.x = -200\n  }\n  else if(direction.RIGHT){\n    player.scale.x = 1\n    player.body.velocity.x = 200\n  }\n  else {\n    player.body.velocity.x = 0\n  }\n  \n  if(direction.UP){\n    player.body.velocity.y = -300\n    player.animations.play('fly')\n  } else {\n    if(!collideDown){\n      player.animations.play('fall')\n    }\n    else if(player.body.velocity.x === 0){\n      player.animations.play('stand')\n    }\n  }\n}\n\nfunction render(){\n\n}\n\nfunction onUp(){\n  direction = { UP: false, DOWN: false, LEFT: false, RIGHT: false }\n}\n\nfunction onDown(){\n  onUp()\n  let dir\n  const isVertical = Math.abs(game.input.x - player.x) < Math.abs(game.input.y - player.y)\n  if(isVertical) dir = game.input.y > player.y ? 'DOWN' : 'UP'\n  else dir = game.input.x > player.x ? 'RIGHT' : 'LEFT'\n  direction[dir] = true\n}\n\nfunction destroyBlock(block){\n  digAnimation = null\n  switch(block.key){\n    case 'rock':\n      break\n    case 'grass':\n    case 'ground':\n      block.destroy()\n      break\n    case 'gold':\n      goldCount++\n      block.destroy()\n      break\n  }\n}", 
        "highlight": [
          { "from": 161, "to": 173 }
        ]
      },
      {
        "text": "<b>Overlap with shop</b>. As a final step in the game we sell gold in the shop by game physics <code>overlap</code> method.",
        "code": "import 'phaser'\n\nconst BLOCK_WIDTH=64, BLOCK_HEIGHT=64\nconst OFFSET_Y=3*64\nlet blocks\nconst blockTypes = ['grass', 'ground', 'gold', 'rock']\nlet player\nlet digAnimation\nlet pointsText\nlet goldCount=0, pointCount=0\nlet cursors\nlet direction = { UP: false, DOWN: false, LEFT: false, RIGHT: false }\n\nconst game = new Phaser.Game(\n  BLOCK_WIDTH*8, \n  BLOCK_HEIGHT*8, \n  Phaser.AUTO, \n  'game', \n  { preload: preload, create: create, update: update, render: render }\n)\n\nfunction preload(){\n  game.load.image('bg', '/api/asset/png/gPDHnefr3cmYtMvur')\n  game.load.image('gold', '/api/asset/png/HrnoQfeqZ8G4Ejy9u')\n  game.load.image('grass', '/api/asset/png/CfdzA4kAGp3JCeqHX')\n  game.load.image('ground', '/api/asset/png/dKYcXBz82W6npYDer')\n  game.load.image('rock', '/api/asset/png/in9dqmm4wCsFd865y')\n  game.load.image('shop', '/api/asset/png/CoW7dywTwBYKvkSfQ')\n  game.load.spritesheet('player', '/api/asset/tileset/FQvBgz8R5AepmBdnE', 90, 90)\n}\n\nfunction create(){\n  game.add.sprite(0, 0, 'bg')\n  shop = game.add.sprite(200, -5, 'shop')\n  blocks = game.add.group()\n  blocks.y = OFFSET_Y\n  for(let row=0; row<6; row++){\n    for(let col=0; col<8; col++){\n      let x = col * BLOCK_WIDTH\n      let y = row * BLOCK_HEIGHT\n      let type = game.rnd.integerInRange(0, blockTypes.length-1)\n      blocks.create(x, y, blockTypes[type])\n    }\n  }\n  \n  player = game.add.sprite(50, 50, 'player')\n  player.anchor.set(0.5, 0.5)\n  player.animations.add('stand', [0, 1, 2, 3], 10, true)\n  player.animations.add('fly', [4, 5, 6, 7], 10, true)\n  player.animations.add('run', [8, 9, 10], 10, true)\n  player.animations.add('fall', [11, 12, 13, 14], 10, true)\n  player.animations.add('dig', [15, 16, 17], 10, false)\n  player.animations.add('dig_down', [18, 19, 20], 10, false)\n  player.animations.play('stand')\n  \n  game.physics.arcade.enable([player, shop, blocks])\n  player.body.collideWorldBounds = true\n  player.body.gravity.y = 1000\n  player.body.width = 50\n  player.body.height = 60\n  blocks.setAll('body.immovable', true)\n  \n  const style = { font: '40px Arial', fill: '#ff0044', align: 'right' }\n  pointsText = game.add.text(game.world.width-50, 5, pointCount, style)\n  pointsText.anchor.set(1, 0)\n  \n  cursors = game.input.keyboard.createCursorKeys()\n  cursors.up.onDown.add(() => direction.UP=true)\n  cursors.up.onUp.add(onUp)\n  cursors.down.onDown.add(() => direction.DOWN=true)\n  cursors.down.onUp.add(onUp)\n  cursors.left.onDown.add(() => direction.LEFT=true)\n  cursors.left.onUp.add(onUp)\n  cursors.right.onDown.add(() => direction.RIGHT=true)\n  cursors.right.onUp.add(onUp)\n  // user input mouse/touch\n  game.input.onDown.add(onDown)\n  game.input.onUp.add(onUp)\n}\n\nfunction update(){\n  let collideDown = false\n  game.physics.arcade.collide(player, blocks, function(character, block){\n    if(digAnimation) return null\n\n    if(direction.LEFT){\n      if(block.body.touching.right){\n        digAnimation = player.animations.play('dig')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('run')\n      }\n    }\n    else if(direction.RIGHT){\n      if(block.body.touching.left){\n        digAnimation = player.animations.play('dig')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('run')\n      }\n    }\n    else if(direction.DOWN){\n      if(block.body.touching.up){\n        digAnimation = player.animations.play('dig_down')\n        digAnimation.onComplete.addOnce( () => destroyBlock(block) )\n      } else {\n        player.animations.play('stand')\n      }\n    }\n\n    if(block.body.touching.up){\n      collideDown = true\n    }\n  }, null)\n  \n  if(digAnimation) return null\n\n  if(direction.LEFT){\n    player.scale.x = -1\n    player.body.velocity.x = -200\n  }\n  else if(direction.RIGHT){\n    player.scale.x = 1\n    player.body.velocity.x = 200\n  }\n  else {\n    player.body.velocity.x = 0\n  }\n  \n  if(direction.UP){\n    player.body.velocity.y = -300\n    player.animations.play('fly')\n  } else {\n    if(!collideDown){\n      player.animations.play('fall')\n    }\n    else if(player.body.velocity.x === 0){\n      player.animations.play('stand')\n    }\n  }\n  \n  game.physics.arcade.overlap(player, shop, function(){\n    if(goldCount > 0){\n      pointCount += goldCount\n      pointsText.setText(pointCount)\n      goldCount = 0\n    }\n  }, null)\n}\n\nfunction render(){\n\n}\n\nfunction onUp(){\n  direction = { UP: false, DOWN: false, LEFT: false, RIGHT: false }\n}\n\nfunction onDown(){\n  onUp()\n  let dir\n  const isVertical = Math.abs(game.input.x - player.x) < Math.abs(game.input.y - player.y)\n  if(isVertical) dir = game.input.y > player.y ? 'DOWN' : 'UP'\n  else dir = game.input.x > player.x ? 'RIGHT' : 'LEFT'\n  direction[dir] = true\n}\n\nfunction destroyBlock(block){\n  digAnimation = null\n  switch(block.key){\n    case 'rock':\n      break\n    case 'grass':\n    case 'ground':\n      block.destroy()\n      break\n    case 'gold':\n      goldCount++\n      block.destroy()\n      break\n  }\n}", 
        "highlight": [
          { "from": 142, "to": 148 }
        ]
      }
    ]
  }
}